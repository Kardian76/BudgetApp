<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="theme-color" content="#0b1320" />
  <title>Purrfect Budget</title>

  <style>
    /* ---------------- Banking-app style theme ---------------- */
    :root{
      --bg0:#070b12;
      --bg1:#0b1320;
      --card:rgba(255,255,255,0.06);
      --cardBorder:rgba(255,255,255,0.10);
      --text:#e9eef7;
      --muted:rgba(233,238,247,0.82);
      --muted2:rgba(233,238,247,0.68);
      --fieldBg:rgba(10,14,22,0.72);
      --fieldBorder:rgba(255,255,255,0.12);
      --fieldBorderHover:rgba(255,255,255,0.18);
      --fieldBorderFocus:rgba(130,190,255,0.65);
      --primary:#2d6cdf;
      --primary2:#1f57c8;
      --danger:#ffb4b4;
      --success:#b6ffcf;
      --shadow: 0 18px 46px rgba(0,0,0,0.38);
      --shadow2: 0 10px 24px rgba(0,0,0,0.28);
      --radius:16px;
      --radiusField:12px;
      --ring: 0 0 0 4px rgba(45,108,223,0.16);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:
        radial-gradient(900px 480px at 10% 0%, rgba(45,108,223,0.22), transparent 60%),
        radial-gradient(720px 360px at 90% 10%, rgba(182,255,207,0.10), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
    }

    .wrap{
      max-width: 860px;
      margin: 0 auto;
      padding: 18px;
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,0.07), rgba(255,255,255,0.045));
      border: 1px solid var(--cardBorder);
      border-radius: var(--radius);
      padding: 18px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }

    .subcard{
      margin-top: 12px;
      box-shadow: var(--shadow2);
      border-radius: var(--radius);
    }

    h1{
      font-size: 18px;
      margin: 0 0 10px;
      letter-spacing: 0.2px;
    }

    p{ margin: 10px 0; line-height: 1.35; color: var(--muted); }
    label{ display:block; margin: 12px 0 6px; font-size: 13px; color: var(--muted); }

    /* Banking-style inputs: consistent everywhere */
    input[type="text"], input[type="password"], select{
      width: 100%;
      padding: 11px 12px;
      border-radius: var(--radiusField);
      border: 1px solid var(--fieldBorder);
      background: var(--fieldBg);
      color: var(--text);
      outline: none;
      transition: border-color .16s ease, box-shadow .16s ease, transform .06s ease;
    }

    input[type="text"]:hover, input[type="password"]:hover, select:hover{
      border-color: var(--fieldBorderHover);
    }

    input[type="text"]:focus, input[type="password"]:focus, select:focus{
      border-color: var(--fieldBorderFocus);
      box-shadow: var(--ring);
    }

    input:disabled{
      opacity: .82;
      cursor: not-allowed;
    }

    .row{
      display:flex;
      gap: 10px;
      align-items:center;
      flex-wrap: wrap;
      margin-top: 12px;
    }

    button{
      appearance:none;
      border: 0;
      border-radius: 12px;
      padding: 11px 14px;
      cursor: pointer;
      color: #fff;
      font-weight: 650;
      background: linear-gradient(180deg, var(--primary), var(--primary2));
      box-shadow: 0 10px 18px rgba(45,108,223,0.22);
      transition: transform .06s ease, filter .16s ease, opacity .16s ease;
    }

    button:hover{ filter: brightness(1.05); }
    button:active{ transform: translateY(1px); }
    button.secondary{
      background: rgba(255,255,255,0.10);
      color: var(--text);
      box-shadow: none;
      border: 1px solid rgba(255,255,255,0.12);
    }

    button:disabled{ opacity: .55; cursor: not-allowed; }

    .status{ margin-top: 12px; font-size: 13px; color: var(--muted2); }
    .error{ color: var(--danger); }
    .ok{ color: var(--success); }
    .hidden{ display:none; }
    .mono{ font-family: ui-monospace, Menlo, Consolas, monospace; }

    pre{
      margin: 10px 0 0;
      padding: 12px;
      border-radius: 14px;
      background: rgba(0,0,0,0.22);
      border: 1px solid rgba(255,255,255,0.10);
      overflow:auto;
    }

    /* ---------------- Step 2: phone-first one-line rows ---------------- */
    .catRow{
      display:flex;
      gap:10px;
      align-items:center;
      margin-top:10px;
      flex-wrap:nowrap; /* always attempt one line */
    }

    /* Critical override: cancel global width:100% for row inputs */
    .catRow input{
      width:auto;
      min-width:0; /* allow shrink */
    }

    /* Category is longer than budget on phones */
    .catRow .catName{
      flex: 1 1 70%;
      min-width: 0;
      max-width: 520px; /* prevents absurdly long on large screens */
    }

    /* Budget is compact and right-aligned */
    .catRow .catBudget{
      flex: 0 0 120px;
      width: 120px;
      text-align:right;
    }

    .catRow .wizRemoveCat{
      flex: 0 0 auto;
      white-space: nowrap;
      padding: 11px 12px;
    }

    @media (max-width: 420px){
      .wrap{ padding: 14px; }
      .catRow .catBudget{
        flex-basis: 108px;
        width: 108px;
      }
    }

    /* Optional: slightly smaller headings on small phones */
    @media (max-width: 360px){
      h1{ font-size: 17px; }
    }
  </style>
</head>

<body>
<div class="wrap">
  <div class="card">
    <h1>Purrfect Budget</h1>

    <!-- ================= AUTH ================= -->
    <div id="authView" class="hidden">
      <p class="status">Enter your bearer token. It will be stored locally in IndexedDB.</p>

      <label for="tokenInput">Bearer Token</label>
      <input id="tokenInput" type="password" placeholder="Paste token…" autocomplete="off" />

      <div class="row">
        <button id="saveTokenBtn" type="button">Save Token</button>
        <button id="toggleTokenBtn" class="secondary" type="button">Show</button>
      </div>

      <div id="authStatus" class="status"></div>
    </div>

    <!-- ================= APP ================= -->
    <div id="appView" class="hidden">
      <p id="appStatus" class="status"></p>

      <div id="hasCategoriesView" class="hidden">
        <p class="ok">Budget categories loaded.</p>
        <pre class="mono" id="categoriesPreview"></pre>
      </div>

      <div id="noCategoriesView" class="hidden">
        <p class="ok">Welcome. Let’s initialize your budget.</p>

        <!-- ---------- STEP 1 ---------- -->
        <div id="wizStep1" class="card subcard">
          <h1>Step 1 — Budget period</h1>

          <label for="wizPeriodType">Period Type</label>
          <select id="wizPeriodType">
            <option value="daily">Daily</option>
            <option value="weekly">Weekly</option>
            <option value="biweekly" selected>Every Two Weeks</option>
            <option value="semi_monthly">Twice a Month</option>
            <option value="monthly">Monthly</option>
            <option value="quarterly">Quarterly</option>
          </select>

          <label for="wizStartDate">Start Date (MM-DD-YYYY)</label>
          <input id="wizStartDate" type="text" placeholder="MM-DD-YYYY" inputmode="numeric" />

          <div class="row">
            <button id="wizNext1" type="button">Next</button>
          </div>
          <div id="wizStatus1" class="status"></div>
        </div>

        <!-- ---------- STEP 2 ---------- -->
        <div id="wizStep2" class="card subcard hidden">
          <h1>Step 2 — Categories</h1>
          <p class="status" style="margin-top:0;">Enter 1–10 categories with starting budgets.</p>

          <div id="wizCatList"></div>

          <div class="row">
            <button id="wizAddCat" class="secondary" type="button">Add Category</button>
            <button id="wizBack2" class="secondary" type="button">Back</button>
            <button id="wizNext2" type="button">Next</button>
          </div>
          <div id="wizStatus2" class="status"></div>
        </div>

        <!-- ---------- STEP 3 ---------- -->
        <div id="wizStep3" class="card subcard hidden">
          <h1>Step 3 — Review</h1>
          <p class="status" style="margin-top:0;">Review and submit your initialization payload.</p>
          <pre id="wizReviewJson" class="mono" style="white-space:pre-wrap;"></pre>

          <div class="row">
            <button id="wizBack3" class="secondary" type="button">Back</button>
            <button id="wizSubmit" type="button">Initialize</button>
          </div>
          <div id="wizStatus3" class="status"></div>
        </div>
      </div>

      <div class="row">
        <button id="logoutBtn" class="secondary" type="button">Log Out</button>
        <button id="retryBtn" class="secondary" type="button">Retry</button>
      </div>
    </div>

    <div id="globalStatus" class="status"></div>
  </div>
</div>

<script>
/* ================= CONFIG ================= */
const API = {
  baseUrl: "https://purrfect-budget-api.kardian.workers.dev",
  validatePath: "/api/auth/validate",
  statePath: "/api/budget/state",
  initPath: "/api/budget/init",
  timeoutMs: 12000
};

/* ================= INDEXEDDB ================= */
const IDB = {
  name: "pwa-budget-app",
  version: 1,
  store: "auth",
  key: "bearerToken"
};

function openDb() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(IDB.name, IDB.version);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(IDB.store)) db.createObjectStore(IDB.store);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function idbGet(key) {
  const db = await openDb();
  try {
    return await new Promise((resolve, reject) => {
      const tx = db.transaction(IDB.store, "readonly");
      const store = tx.objectStore(IDB.store);
      const req = store.get(key);
      req.onsuccess = () => resolve(req.result ?? null);
      req.onerror = () => reject(req.error);
    });
  } finally { db.close(); }
}

async function idbSet(key, value) {
  const db = await openDb();
  try {
    return await new Promise((resolve, reject) => {
      const tx = db.transaction(IDB.store, "readwrite");
      const store = tx.objectStore(IDB.store);
      const req = store.put(value, key);
      req.onsuccess = () => resolve(true);
      req.onerror = () => reject(req.error);
    });
  } finally { db.close(); }
}

async function idbDel(key) {
  const db = await openDb();
  try {
    return await new Promise((resolve, reject) => {
      const tx = db.transaction(IDB.store, "readwrite");
      const store = tx.objectStore(IDB.store);
      const req = store.delete(key);
      req.onsuccess = () => resolve(true);
      req.onerror = () => reject(req.error);
    });
  } finally { db.close(); }
}

/* ================= DOM ================= */
const $ = (id) => document.getElementById(id);

const authView = $("authView");
const tokenInput = $("tokenInput");
const saveTokenBtn = $("saveTokenBtn");
const toggleTokenBtn = $("toggleTokenBtn");
const authStatus = $("authStatus");

const appView = $("appView");
const appStatus = $("appStatus");
const hasCategoriesView = $("hasCategoriesView");
const noCategoriesView = $("noCategoriesView");
const categoriesPreview = $("categoriesPreview");

const logoutBtn = $("logoutBtn");
const retryBtn = $("retryBtn");
const globalStatus = $("globalStatus");

const wizStep1 = $("wizStep1");
const wizStep2 = $("wizStep2");
const wizStep3 = $("wizStep3");

const wizPeriodType = $("wizPeriodType");
const wizStartDate = $("wizStartDate");

const wizCatList = $("wizCatList");
const wizReviewJson = $("wizReviewJson");

const wizNext1 = $("wizNext1");
const wizBack2 = $("wizBack2");
const wizNext2 = $("wizNext2");
const wizAddCat = $("wizAddCat");

const wizBack3 = $("wizBack3");
const wizSubmit = $("wizSubmit");

const wizStatus1 = $("wizStatus1");
const wizStatus2 = $("wizStatus2");
const wizStatus3 = $("wizStatus3");

/* ================= UI HELPERS ================= */
function show(el) { if (el) el.classList.remove("hidden"); }
function hide(el) { if (el) el.classList.add("hidden"); }

function setStatus(el, msg, kind) {
  if (!el) return;
  el.textContent = msg || "";
  el.classList.remove("error", "ok");
  if (kind) el.classList.add(kind);
}

function setBusy(isBusy) {
  const btns = [
    saveTokenBtn, toggleTokenBtn, logoutBtn, retryBtn,
    wizNext1, wizBack2, wizNext2, wizAddCat, wizBack3, wizSubmit
  ].filter(Boolean);
  for (const b of btns) b.disabled = !!isBusy;
}

function showAuth(message = "", isError = false) {
  show(authView);
  hide(appView);
  setStatus(authStatus, message, isError ? "error" : "");
  setStatus(globalStatus, "");
  tokenInput?.focus();
}

function showApp(message = "") {
  hide(authView);
  show(appView);
  setStatus(appStatus, message);
}

/* ================= URL + FETCH ================= */
function joinUrl(base, path) {
  return base.replace(/\/+$/, "") + "/" + path.replace(/^\/+/, "");
}

function authHeaders(token) {
  return {
    "Authorization": `Bearer ${token}`,
    "Content-Type": "application/json"
  };
}

function fetchWithTimeout(url, options = {}) {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), API.timeoutMs);
  return fetch(url, { ...options, signal: controller.signal })
    .finally(() => clearTimeout(id));
}

async function safeText(resp) {
  try { return await resp.text(); } catch { return ""; }
}

/* ================= API ================= */
async function validateToken(token) {
  const url = joinUrl(API.baseUrl, API.validatePath);
  const resp = await fetchWithTimeout(url, { method: "GET", headers: authHeaders(token) });
  if (resp.ok) return true;
  if (resp.status === 401 || resp.status === 403) return false;
  const t = await safeText(resp);
  throw new Error(`Token validate failed (${resp.status}): ${t || resp.statusText}`);
}

async function fetchState(token) {
  const url = joinUrl(API.baseUrl, API.statePath);
  const resp = await fetchWithTimeout(url, { method: "GET", headers: authHeaders(token) });

  if (!resp.ok) {
    if (resp.status === 401 || resp.status === 403) return { authFailed: true, state: null };
    const t = await safeText(resp);
    throw new Error(`State failed (${resp.status}): ${t || resp.statusText}`);
  }
  return { authFailed: false, state: await resp.json().catch(() => ({})) };
}

async function postInit(token, payload) {
  const url = joinUrl(API.baseUrl, API.initPath);
  const resp = await fetchWithTimeout(url, {
    method: "POST",
    headers: authHeaders(token),
    body: JSON.stringify(payload)
  });

  if (!resp.ok) {
    if (resp.status === 401 || resp.status === 403) return { authFailed: true, result: null };
    const t = await safeText(resp);
    throw new Error(`Init failed (${resp.status}): ${t || resp.statusText}`);
  }
  return { authFailed: false, result: await resp.json().catch(() => ({})) };
}

/* ================= DATE HELPERS (UI MM-DD-YYYY) ================= */
const pad2 = (n) => String(n).padStart(2, "0");

function todayYMD() {
  const d = new Date();
  return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
}

function ymdToMdy(ymd) {
  const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(String(ymd || ""));
  if (!m) return "";
  return `${m[2]}-${m[3]}-${m[1]}`;
}

function mdyToYmd(mdy) {
  const s = String(mdy || "").trim();
  const m = /^(\d{2})-(\d{2})-(\d{4})$/.exec(s);
  if (!m) return null;

  const mm = Number(m[1]), dd = Number(m[2]), yyyy = Number(m[3]);
  if (yyyy < 1900 || yyyy > 2100) return null;
  if (mm < 1 || mm > 12) return null;
  if (dd < 1 || dd > 31) return null;

  const dt = new Date(yyyy, mm - 1, dd);
  if (dt.getFullYear() !== yyyy || dt.getMonth() !== (mm - 1) || dt.getDate() !== dd) return null;

  return `${yyyy}-${pad2(mm)}-${pad2(dd)}`;
}

function periodUsesStartDate(periodType) {
  return periodType === "weekly" || periodType === "biweekly" || periodType === "quarterly";
}

function disabledStartDateMessage(periodType) {
  switch (periodType) {
    case "daily": return "Not needed for Daily budgets";
    case "monthly": return "Not needed for Monthly budgets";
    case "semi_monthly": return "Not needed for Twice-a-Month budgets";
    default: return "Not needed for this period type";
  }
}

function updateStartDateAvailability() {
  const pt = (wizPeriodType?.value || "").trim();
  const uses = periodUsesStartDate(pt);

  if (!wizStartDate) return;

  if (uses) {
    const prev = wizStartDate.dataset.prevValue;
    wizStartDate.disabled = false;
    wizStartDate.placeholder = "MM-DD-YYYY";
    if (prev && wizStartDate.value.startsWith("Not needed")) {
      wizStartDate.value = prev;
    }
    if (!wizStartDate.value || wizStartDate.value.startsWith("Not needed")) {
      wizStartDate.value = ymdToMdy(todayYMD());
    }
  } else {
    if (wizStartDate.value && !wizStartDate.value.startsWith("Not needed")) {
      wizStartDate.dataset.prevValue = wizStartDate.value;
    }
    wizStartDate.disabled = true;
    wizStartDate.value = disabledStartDateMessage(pt);
  }
}

/* ================= Currency helpers ($ prefix) ================= */
function normalizeBudgetDisplay(s) {
  // Allow user to type: 250, 250.5, $250.50
  const raw = String(s || "").trim().replace(/[^0-9.]/g, "");
  if (!raw) return "";
  const n = Number(raw);
  if (!Number.isFinite(n)) return "";
  // Keep two decimals for display
  return "$" + n.toFixed(2);
}

function budgetDisplayToNumericString(s) {
  const raw = String(s || "").trim().replace(/[^0-9.]/g, "");
  if (!raw) return "";
  const n = Number(raw);
  if (!Number.isFinite(n)) return "";
  // Send dollars with 2 decimals (string) to match your existing API parsing
  return n.toFixed(2);
}

/* ================= WIZARD ================= */
function showStep(stepIndex) {
  [wizStep1, wizStep2, wizStep3].forEach((el, idx) => {
    if (!el) return;
    el.classList.toggle("hidden", idx !== stepIndex);
  });
}

function escapeHtml(s) {
  return String(s)
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

function addWizCategoryRow(name = "", dollars = "") {
  const row = document.createElement("div");
  row.className = "catRow";

  const display = dollars ? normalizeBudgetDisplay(dollars) : "";

  row.innerHTML = `
    <input class="catName" type="text" placeholder="Category" value="${escapeHtml(name)}" />
    <input class="catBudget"
           type="text"
           inputmode="decimal"
           placeholder="$0.00"
           value="${escapeHtml(display)}" />
    <button class="secondary wizRemoveCat" type="button">Remove</button>
  `;

  const b = row.querySelector(".catBudget");

  // Non-blocking: keep typing natural; enforce $ format on blur
  b.addEventListener("blur", () => {
    b.value = normalizeBudgetDisplay(b.value);
  });

  // If user focuses a formatted value, keep it as-is (banking-app feel)
  // Optionally, you could strip $ on focus; leaving as-is is simpler.

  row.querySelector(".wizRemoveCat").addEventListener("click", () => row.remove());
  wizCatList.appendChild(row);
}

function readCategoriesFromUI() {
  const rows = Array.from(wizCatList.querySelectorAll(".catRow"));
  return rows.map((r, idx) => {
    const name = r.querySelector(".catName")?.value?.trim() || "";
    const budgetNumeric = budgetDisplayToNumericString(r.querySelector(".catBudget")?.value || "");
    return { name, budget_dollars: budgetNumeric, sort_order: idx + 1 };
  }).filter(c => c.name.length > 0);
}

function validateStep1() {
  const pt = (wizPeriodType.value || "").trim();
  const allowed = new Set(["daily", "weekly", "biweekly", "semi_monthly", "monthly", "quarterly"]);
  if (!allowed.has(pt)) return "Invalid period type.";

  if (periodUsesStartDate(pt)) {
    const ymd = mdyToYmd(wizStartDate.value);
    if (!ymd) return "Start Date must be MM-DD-YYYY.";
  }
  return null;
}

function validateStep2() {
  const cats = readCategoriesFromUI();
  if (cats.length < 1 || cats.length > 10) return "Please provide 1 to 10 categories.";

  const seen = new Set();
  for (const c of cats) {
    if (!c.name) return "Category name cannot be blank.";
    if (c.name.length > 64) return `Category name too long: ${c.name}`;
    if (!c.budget_dollars || !String(c.budget_dollars).trim()) return `Please enter a budget for: ${c.name}`;

    const k = c.name.toLowerCase();
    if (seen.has(k)) return `Duplicate category name: ${c.name}`;
    seen.add(k);
  }
  return null;
}

function effectiveStartDateYmd() {
  const pt = (wizPeriodType.value || "").trim();
  if (!periodUsesStartDate(pt)) return todayYMD();
  return mdyToYmd(wizStartDate.value);
}

function buildInitPayload() {
  return {
    period_type: (wizPeriodType.value || "").trim(),
    period_anchor_date: effectiveStartDateYmd(),
    categories: readCategoriesFromUI().map(c => ({
      name: c.name,
      sort_order: c.sort_order,
      budget_dollars: c.budget_dollars
    }))
  };
}

function renderReview() {
  const payload = buildInitPayload();
  wizReviewJson.textContent = JSON.stringify(payload, null, 2);
}

function initWizardDefaults() {
  if (!wizStartDate.value || wizStartDate.value === "MM-DD-YYYY") {
    wizStartDate.value = ymdToMdy(todayYMD());
  }

  if (wizCatList.children.length === 0) {
    addWizCategoryRow("Groceries", "300.00");
    addWizCategoryRow("Gas", "120.00");
  }

  updateStartDateAvailability();
  showStep(0);
}

/* ================= APP FLOW ================= */
async function loadAppState(token) {
  showApp("Connected. Loading budget state…");
  hide(hasCategoriesView);
  hide(noCategoriesView);
  categoriesPreview.textContent = "";

  const result = await fetchState(token);
  if (result.authFailed) {
    await idbDel(IDB.key);
    return showAuth("Stored token is invalid/expired. Please re-enter.", true);
  }

  const state = result.state || {};
  const categories = Array.isArray(state.categories) ? state.categories : [];

  if (state.initialized === false) {
    show(noCategoriesView);
    setStatus(appStatus, "Budget not yet initialized.");
    initWizardDefaults();
    return;
  }

  if (categories.length > 0) {
    show(hasCategoriesView);
    setStatus(appStatus, "Categories found.");
    categoriesPreview.textContent = JSON.stringify(categories, null, 2);
  } else {
    show(noCategoriesView);
    setStatus(appStatus, "Initialized, but no categories found. Starting setup.");
    initWizardDefaults();
  }
}

async function bootstrap() {
  setBusy(true);
  setStatus(globalStatus, "Starting…");
  hide(authView);
  hide(appView);

  const token = await idbGet(IDB.key);

  if (!token) {
    setBusy(false);
    return showAuth("No token saved. Enter your bearer token to continue.");
  }

  try {
    setStatus(globalStatus, "Validating token…");
    const ok = await validateToken(token);
    if (!ok) {
      await idbDel(IDB.key);
      setBusy(false);
      return showAuth("Saved token is invalid or expired. Please enter a new token.", true);
    }

    await loadAppState(token);
    setStatus(globalStatus, "");
    setBusy(false);
  } catch (e) {
    setBusy(false);
    showAuth(`Startup error: ${e.message}`, true);
  }
}

/* ================= EVENTS ================= */
saveTokenBtn.addEventListener("click", async () => {
  const token = (tokenInput.value || "").trim();
  if (!token) return setStatus(authStatus, "Please enter a token.", "error");

  setBusy(true);
  setStatus(authStatus, "Validating token…");
  try {
    const ok = await validateToken(token);
    if (!ok) {
      setBusy(false);
      return setStatus(authStatus, "Token is invalid or expired.", "error");
    }
    await idbSet(IDB.key, token);
    setStatus(authStatus, "Token saved. Loading…", "ok");
    await loadAppState(token);
    setBusy(false);
  } catch (e) {
    setBusy(false);
    setStatus(authStatus, `Unable to validate token: ${e.message}`, "error");
  }
});

toggleTokenBtn.addEventListener("click", () => {
  const isPw = tokenInput.type === "password";
  tokenInput.type = isPw ? "text" : "password";
  toggleTokenBtn.textContent = isPw ? "Hide" : "Show";
  tokenInput.focus();
});

logoutBtn.addEventListener("click", async () => {
  setBusy(true);
  await idbDel(IDB.key);
  setBusy(false);
  showAuth("Logged out. Enter your bearer token to continue.");
});

retryBtn.addEventListener("click", async () => {
  await bootstrap();
});

wizPeriodType.addEventListener("change", updateStartDateAvailability);

wizNext1.addEventListener("click", () => {
  const err = validateStep1();
  if (err) return setStatus(wizStatus1, err, "error");
  setStatus(wizStatus1, "", "");
  showStep(1);
});

wizBack2.addEventListener("click", () => showStep(0));

wizAddCat.addEventListener("click", () => addWizCategoryRow());

wizNext2.addEventListener("click", () => {
  const err = validateStep2();
  if (err) return setStatus(wizStatus2, err, "error");
  setStatus(wizStatus2, "", "");
  renderReview();
  showStep(2);
});

wizBack3.addEventListener("click", () => showStep(1));

wizSubmit.addEventListener("click", async () => {
  const err1 = validateStep1();
  if (err1) { showStep(0); return setStatus(wizStatus1, err1, "error"); }

  const err2 = validateStep2();
  if (err2) { showStep(1); return setStatus(wizStatus2, err2, "error"); }

  const token = await idbGet(IDB.key);
  if (!token) return showAuth("Missing token. Please re-enter.", true);

  const payload = buildInitPayload();

  setBusy(true);
  setStatus(wizStatus3, "Initializing…");

  try {
    const res = await postInit(token, payload);
    if (res.authFailed) {
      await idbDel(IDB.key);
      setBusy(false);
      return showAuth("Token invalid/expired. Please re-enter.", true);
    }
    setStatus(wizStatus3, "Initialized. Reloading…", "ok");
    await loadAppState(token);
    setBusy(false);
  } catch (e) {
    setBusy(false);
    setStatus(wizStatus3, e.message, "error");
  }
});

/* ================= START ================= */
bootstrap();
</script>
</body>
</html>
