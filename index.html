<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="theme-color" content="#0b1320" />
  <title>PWA Budget App</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; padding: 0; background: #0b1320; color: #e9eef7; }
    .wrap { max-width: 720px; margin: 0 auto; padding: 24px; }
    .card { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.10); border-radius: 14px; padding: 18px; }
    h1 { font-size: 18px; margin: 0 0 12px; }
    p { margin: 10px 0; line-height: 1.35; color: rgba(233,238,247,0.9); }
    label { display: block; margin: 12px 0 6px; font-size: 13px; color: rgba(233,238,247,0.85); }
    input[type="password"], input[type="text"] {
      width: 100%; box-sizing: border-box;
      padding: 10px 12px; border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(0,0,0,0.25); color: #e9eef7;
      outline: none;
    }
    input:focus { border-color: rgba(130,190,255,0.6); }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-top: 12px; }
    button {
      appearance: none; border: 0; border-radius: 10px;
      padding: 10px 12px; cursor: pointer;
      background: #2d6cdf; color: white; font-weight: 600;
    }
    button.secondary { background: rgba(255,255,255,0.10); color: #e9eef7; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    .status { margin-top: 12px; font-size: 13px; color: rgba(233,238,247,0.85); }
    .error { color: #ffb4b4; }
    .ok { color: #b6ffcf; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .hidden { display: none; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <h1>PWA Budget App</h1>

      <!-- Auth / Token Prompt -->
      <div id="authView" class="hidden">
        <p>This app requires a bearer token on first launch. The token will be stored locally in IndexedDB.</p>

        <label for="tokenInput">Bearer Token</label>
        <input id="tokenInput" type="password" autocomplete="off" placeholder="Paste token…" />

        <div class="row">
          <button id="saveTokenBtn">Save Token</button>
          <button id="toggleTokenBtn" class="secondary" type="button">Show</button>
        </div>

        <div id="authStatus" class="status"></div>
      </div>

      <!-- App Views -->
      <div id="appView" class="hidden">
        <p id="appStatus" class="status"></p>

        <div id="hasCategoriesView" class="hidden">
          <p class="ok">Existing budget categories found. Loading your dashboard…</p>
          <p class="mono" id="categoriesPreview"></p>
        </div>

        <div id="noCategoriesView" class="hidden">
          <p class="ok">No budget categories found yet. Starting onboarding…</p>
          <p class="mono">Next step: show “Create Categories” flow.</p>
        </div>

        <div class="row">
          <button id="logoutBtn" class="secondary" type="button">Log Out</button>
          <button id="retryBtn" class="secondary" type="button">Retry</button>
        </div>
      </div>

      <!-- Global Status -->
      <div id="globalStatus" class="status"></div>
    </div>
  </div>

  <script>
    /**
     * CONFIGURATION
     * Update these endpoints to match your backend.
     *
     * - validate: a lightweight endpoint that verifies token validity.
     *   Expected: 200 OK if valid. 401/403 if invalid/expired.
     *
     * - categories: an endpoint that returns user's budget categories.
     *   Expected: 200 OK with JSON array: [{...}, ...]
     *             404/200 [] for none (depends on your API)
     */
    const API = {
      baseUrl: "", // e.g. "https://api.yourdomain.com"
      validatePath: "/api/auth/validate",
      categoriesPath: "/api/budget/categories",
      timeoutMs: 12000
    };

    /**
     * IndexedDB settings
     */
    const DB = {
      name: "pwa-budget-app",
      version: 1,
      store: "auth",
      tokenKey: "bearerToken"
    };

    // ---------- DOM ----------
    const authView = document.getElementById("authView");
    const tokenInput = document.getElementById("tokenInput");
    const saveTokenBtn = document.getElementById("saveTokenBtn");
    const toggleTokenBtn = document.getElementById("toggleTokenBtn");
    const authStatus = document.getElementById("authStatus");

    const appView = document.getElementById("appView");
    const appStatus = document.getElementById("appStatus");
    const hasCategoriesView = document.getElementById("hasCategoriesView");
    const noCategoriesView = document.getElementById("noCategoriesView");
    const categoriesPreview = document.getElementById("categoriesPreview");

    const logoutBtn = document.getElementById("logoutBtn");
    const retryBtn = document.getElementById("retryBtn");

    const globalStatus = document.getElementById("globalStatus");

    // ---------- Utilities ----------
    function setStatus(el, msg, kind) {
      el.textContent = msg || "";
      el.classList.remove("error", "ok");
      if (kind) el.classList.add(kind);
    }

    function show(el) { el.classList.remove("hidden"); }
    function hide(el) { el.classList.add("hidden"); }

    function setBusy(isBusy) {
      saveTokenBtn.disabled = isBusy;
      retryBtn.disabled = isBusy;
      logoutBtn.disabled = isBusy;
    }

    function joinUrl(base, path) {
      if (!base) return path;
      return base.replace(/\/+$/, "") + "/" + path.replace(/^\/+/, "");
    }

    // ---------- IndexedDB Token Storage ----------
    function openDb() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB.name, DB.version);

        req.onupgradeneeded = () => {
          const db = req.result;
          if (!db.objectStoreNames.contains(DB.store)) {
            db.createObjectStore(DB.store);
          }
        };

        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function idbGet(key) {
      const db = await openDb();
      try {
        return await new Promise((resolve, reject) => {
          const tx = db.transaction(DB.store, "readonly");
          const store = tx.objectStore(DB.store);
          const req = store.get(key);
          req.onsuccess = () => resolve(req.result ?? null);
          req.onerror = () => reject(req.error);
        });
      } finally {
        db.close();
      }
    }

    async function idbSet(key, value) {
      const db = await openDb();
      try {
        return await new Promise((resolve, reject) => {
          const tx = db.transaction(DB.store, "readwrite");
          const store = tx.objectStore(DB.store);
          const req = store.put(value, key);
          req.onsuccess = () => resolve(true);
          req.onerror = () => reject(req.error);
        });
      } finally {
        db.close();
      }
    }

    async function idbDel(key) {
      const db = await openDb();
      try {
        return await new Promise((resolve, reject) => {
          const tx = db.transaction(DB.store, "readwrite");
          const store = tx.objectStore(DB.store);
          const req = store.delete(key);
          req.onsuccess = () => resolve(true);
          req.onerror = () => reject(req.error);
        });
      } finally {
        db.close();
      }
    }

    // ---------- Fetch Helpers ----------
    function fetchWithTimeout(url, options = {}) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), API.timeoutMs);

      return fetch(url, { ...options, signal: controller.signal })
        .finally(() => clearTimeout(id));
    }

    function authHeaders(token) {
      return {
        "Authorization": `Bearer ${token}`,
        "Content-Type": "application/json"
      };
    }

    // ---------- API Calls ----------
    async function validateToken(token) {
      const url = joinUrl(API.baseUrl, API.validatePath);

      // If you do not have a dedicated endpoint, you can treat a call to
      // the categories endpoint as your validation check instead.
      const resp = await fetchWithTimeout(url, {
        method: "GET",
        headers: authHeaders(token)
      });

      if (resp.ok) return true;

      if (resp.status === 401 || resp.status === 403) return false;

      // Other failures are treated as transient (network/server).
      const text = await safeReadText(resp);
      throw new Error(`Token validation failed (${resp.status}): ${text || resp.statusText}`);
    }

    async function fetchCategories(token) {
      const url = joinUrl(API.baseUrl, API.categoriesPath);
      const resp = await fetchWithTimeout(url, {
        method: "GET",
        headers: authHeaders(token)
      });

      if (!resp.ok) {
        if (resp.status === 401 || resp.status === 403) {
          // Token invalid/expired.
          return { authFailed: true, categories: null };
        }
        const text = await safeReadText(resp);
        throw new Error(`Categories request failed (${resp.status}): ${text || resp.statusText}`);
      }

      const data = await resp.json().catch(() => null);
      const categories = Array.isArray(data) ? data : (data?.categories ?? []);
      return { authFailed: false, categories };
    }

    async function safeReadText(resp) {
      try { return await resp.text(); } catch { return ""; }
    }

    // ---------- App State Machine (Launch Flow) ----------
    async function bootstrap() {
      setBusy(true);
      setStatus(globalStatus, "Starting…");
      hide(authView);
      hide(appView);

      const token = await idbGet(DB.tokenKey);

      if (!token) {
        // No token stored: prompt once.
        setBusy(false);
        setStatus(globalStatus, "");
        return showAuth("No token found. Enter your bearer token to continue.");
      }

      // Token exists: validate then continue.
      try {
        setStatus(globalStatus, "Validating token…");
        const isValid = await validateToken(token);

        if (!isValid) {
          await idbDel(DB.tokenKey);
          setBusy(false);
          setStatus(globalStatus, "");
          return showAuth("Stored token is invalid or expired. Please enter a new token.", true);
        }

        // Token is valid: proceed to categories check.
        setStatus(globalStatus, "Loading your data…");
        await showAppWithCategories(token);

        setStatus(globalStatus, "");
        setBusy(false);
      } catch (err) {
        // Network/server error: don't destroy token; allow retry.
        setBusy(false);
        show(appView);
        hide(authView);

        setStatus(appStatus, `Unable to complete startup: ${err.message}`, "error");
        hide(hasCategoriesView);
        hide(noCategoriesView);
        setStatus(globalStatus, "Startup encountered an error. You can Retry.", "error");
      }
    }

    function showAuth(message, isError = false) {
      show(authView);
      hide(appView);
      setStatus(authStatus, message, isError ? "error" : "");
      tokenInput.value = "";
      tokenInput.focus();
    }

    async function showAppWithCategories(token) {
      show(appView);
      hide(authView);
      setStatus(appStatus, "Connected. Checking budget categories…");

      hide(hasCategoriesView);
      hide(noCategoriesView);
      categoriesPreview.textContent = "";

      const result = await fetchCategories(token);

      if (result.authFailed) {
        // Token no longer valid mid-flight (revoked/expired)
        await idbDel(DB.tokenKey);
        return showAuth("Your token is no longer valid. Please enter a new token.", true);
      }

      const categories = result.categories || [];
      if (categories.length > 0) {
        show(hasCategoriesView);
        hide(noCategoriesView);
        setStatus(appStatus, "Categories found.");
        // Preview limited to keep UI simple
        categoriesPreview.textContent = JSON.stringify(categories.slice(0, 5), null, 2) +
          (categories.length > 5 ? `\n… (${categories.length - 5} more)` : "");
      } else {
        hide(hasCategoriesView);
        show(noCategoriesView);
        setStatus(appStatus, "No categories found.");
      }
    }

    // ---------- Event Handlers ----------
    saveTokenBtn.addEventListener("click", async () => {
      const token = (tokenInput.value || "").trim();
      if (!token) return setStatus(authStatus, "Please enter a token.", "error");

      setBusy(true);
      setStatus(authStatus, "Validating token…");
      setStatus(globalStatus, "");

      try {
        const isValid = await validateToken(token);
        if (!isValid) {
          setBusy(false);
          return setStatus(authStatus, "Token is invalid or expired. Please try again.", "error");
        }

        await idbSet(DB.tokenKey, token);
        setStatus(authStatus, "Token saved.", "ok");

        // Proceed to categories check immediately.
        await showAppWithCategories(token);

        setBusy(false);
      } catch (err) {
        setBusy(false);
        setStatus(authStatus, `Unable to validate token: ${err.message}`, "error");
      }
    });

    toggleTokenBtn.addEventListener("click", () => {
      const isPassword = tokenInput.type === "password";
      tokenInput.type = isPassword ? "text" : "password";
      toggleTokenBtn.textContent = isPassword ? "Hide" : "Show";
      tokenInput.focus();
    });

    logoutBtn.addEventListener("click", async () => {
      setBusy(true);
      await idbDel(DB.tokenKey);
      setBusy(false);
      showAuth("Logged out. Enter your bearer token to continue.");
    });

    retryBtn.addEventListener("click", async () => {
      await bootstrap();
    });

    // ---------- Init ----------
    // Optional: basic service worker registration (safe to remove if handled elsewhere)
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker.register("./service-worker.js").catch(() => {});
      });
    }

    // Start the app
    bootstrap();
  </script>
</body>
</html>
