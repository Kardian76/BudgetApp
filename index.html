<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="theme-color" content="#0b1320" />
  <title>PWA Budget App</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; padding: 0; background: #0b1320; color: #e9eef7; }
    .wrap { max-width: 720px; margin: 0 auto; padding: 24px; }
    .card { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.10); border-radius: 14px; padding: 18px; }
    h1 { font-size: 18px; margin: 0 0 12px; }
    p { margin: 10px 0; line-height: 1.35; color: rgba(233,238,247,0.9); }
    label { display: block; margin: 12px 0 6px; font-size: 13px; color: rgba(233,238,247,0.85); }
    input[type="password"], input[type="text"] {
      width: 100%; box-sizing: border-box;
      padding: 10px 12px; border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(0,0,0,0.25); color: #e9eef7;
      outline: none;
    }
    input:focus { border-color: rgba(130,190,255,0.6); }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-top: 12px; }
    button {
      appearance: none; border: 0; border-radius: 10px;
      padding: 10px 12px; cursor: pointer;
      background: #2d6cdf; color: white; font-weight: 600;
    }
    button.secondary { background: rgba(255,255,255,0.10); color: #e9eef7; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    .status { margin-top: 12px; font-size: 13px; color: rgba(233,238,247,0.85); }
    .error { color: #ffb4b4; }
    .ok { color: #b6ffcf; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .hidden { display: none; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <h1>PWA Budget App</h1>

      <!-- Auth / Token Prompt -->
      <div id="authView" class="hidden">
        <p>This app requires a bearer token on first launch. The token will be stored locally in IndexedDB.</p>

        <label for="tokenInput">Bearer Token</label>
        <input id="tokenInput" type="password" autocomplete="off" placeholder="Paste token…" />

        <div class="row">
          <button id="saveTokenBtn">Save Token</button>
          <button id="toggleTokenBtn" class="secondary" type="button">Show</button>
        </div>

        <div id="authStatus" class="status"></div>
      </div>

      <!-- App Views -->
      <div id="appView" class="hidden">
        <p id="appStatus" class="status"></p>

        <div id="hasCategoriesView" class="hidden">
          <p class="ok">Existing budget categories found. Loading your dashboard…</p>
          <p class="mono" id="categoriesPreview"></p>
        </div>

        <div id="noCategoriesView" class="hidden">
 <div id="initView">
  <p class="ok">Budget not initialized. Please enter your starting setup.</p>

  <label for="periodType">Period Type</label>
  <input id="periodType" type="text" value="semi_monthly" placeholder="daily/weekly/biweekly/semi_monthly/monthly/quarterly" />

  <label for="anchorDate">Period Anchor Date (YYYY-MM-DD)</label>
  <input id="anchorDate" type="text" placeholder="2026-01-01" />

  <p style="margin-top:14px;">Categories (1–10)</p>
  <div id="catList"></div>

  <div class="row">
    <button id="addCatBtn" class="secondary" type="button">Add Category</button>
    <button id="initBtn" type="button">Initialize Budget</button>
  </div>

  <div id="initStatus" class="status"></div>
</div>

        </div>

        <div class="row">
          <button id="logoutBtn" class="secondary" type="button">Log Out</button>
          <button id="retryBtn" class="secondary" type="button">Retry</button>
        </div>
      </div>

      <!-- Global Status -->
      <div id="globalStatus" class="status"></div>
    </div>
  </div>
  <script>
    /**
     * CONFIGURATION
     * - validate: GET /api/auth/validate  (200 ok, 401/403 invalid)
     * - state:    GET /api/budget/state  (returns initialized + categories array)
     */
    const API = {
  baseUrl: "https://purrfect-budget-api.kardian.workers.dev",
  validatePath: "/api/auth/validate",
  statePath: "/api/budget/state",
  initPath: "/api/budget/init",
  timeoutMs: 12000
};


    /**
     * IndexedDB settings
     */
    const DB = {
      name: "pwa-budget-app",
      version: 1,
      store: "auth",
      tokenKey: "bearerToken"
    };

    // ---------- DOM ----------
    const authView = document.getElementById("authView");
    const tokenInput = document.getElementById("tokenInput");
    const saveTokenBtn = document.getElementById("saveTokenBtn");
    const toggleTokenBtn = document.getElementById("toggleTokenBtn");
    const authStatus = document.getElementById("authStatus");

    const appView = document.getElementById("appView");
    const appStatus = document.getElementById("appStatus");
    const hasCategoriesView = document.getElementById("hasCategoriesView");
    const noCategoriesView = document.getElementById("noCategoriesView");
    const categoriesPreview = document.getElementById("categoriesPreview");

    const logoutBtn = document.getElementById("logoutBtn");
    const retryBtn = document.getElementById("retryBtn");

    const globalStatus = document.getElementById("globalStatus");

    const initStatus = document.getElementById("initStatus");
const periodTypeEl = document.getElementById("periodType");
const anchorDateEl = document.getElementById("anchorDate");
const catListEl = document.getElementById("catList");
const addCatBtn = document.getElementById("addCatBtn");
const initBtn = document.getElementById("initBtn");

function addCategoryRow(name = "", dollars = "") {
  const row = document.createElement("div");
  row.className = "row";
  row.innerHTML = `
    <input class="catName" type="text" placeholder="Category name" value="${escapeHtml(name)}" style="flex: 1; min-width: 180px;" />
    <input class="catBudget" type="text" placeholder="Budget (e.g., 250.00)" value="${escapeHtml(dollars)}" style="width: 180px;" />
    <button class="secondary removeCatBtn" type="button">Remove</button>
  `;
  row.querySelector(".removeCatBtn").addEventListener("click", () => row.remove());
  catListEl.appendChild(row);
}

function escapeHtml(s) {
  return String(s)
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

addCatBtn?.addEventListener("click", () => addCategoryRow());

initBtn?.addEventListener("click", async () => {
  const token = await idbGet(DB.tokenKey);
  if (!token) return showAuth("Missing token. Please re-enter your bearer token.", true);

  const period_type = (periodTypeEl.value || "").trim();
  const period_anchor_date = (anchorDateEl.value || "").trim();

  const rows = Array.from(catListEl.querySelectorAll(".row"));
  const categories = rows.map((r, idx) => {
    const name = r.querySelector(".catName").value.trim();
    const budget_dollars = r.querySelector(".catBudget").value.trim();
    return { name, sort_order: idx + 1, budget_dollars };
  }).filter(c => c.name);

  // Basic client-side validation (server will still enforce rules)
  if (!period_type) return setStatus(initStatus, "Please enter a period type.", "error");
  if (!/^\d{4}-\d{2}-\d{2}$/.test(period_anchor_date)) {
    return setStatus(initStatus, "Anchor date must be YYYY-MM-DD.", "error");
  }
  if (categories.length < 1 || categories.length > 10) {
    return setStatus(initStatus, "Please provide 1 to 10 categories.", "error");
  }

  setBusy(true);
  setStatus(initStatus, "Initializing…");

  try {
    const res = await postInit(token, { period_type, period_anchor_date, categories });
    if (res.authFailed) {
      await idbDel(DB.tokenKey);
      setBusy(false);
      return showAuth("Token invalid/expired. Please enter a new token.", true);
    }

    setStatus(initStatus, "Initialized. Loading state…", "ok");
    // Reload main view
    await showAppWithState(token);
    setBusy(false);
  } catch (e) {
    setBusy(false);
    setStatus(initStatus, e.message, "error");
  }
});

// Seed with 2 default rows for usability
if (catListEl && catListEl.children.length === 0) {
  addCategoryRow("Groceries", "300.00");
  addCategoryRow("Gas", "120.00");
}


    // ---------- Utilities ----------
    function setStatus(el, msg, kind) {
      el.textContent = msg || "";
      el.classList.remove("error", "ok");
      if (kind) el.classList.add(kind);
    }

    function show(el) { el.classList.remove("hidden"); }
    function hide(el) { el.classList.add("hidden"); }

    function setBusy(isBusy) {
      saveTokenBtn.disabled = isBusy;
      retryBtn.disabled = isBusy;
      logoutBtn.disabled = isBusy;
    }

    function joinUrl(base, path) {
      if (!base) return path;
      return base.replace(/\/+$/, "") + "/" + path.replace(/^\/+/, "");
    }

    // ---------- IndexedDB Token Storage ----------
    function openDb() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB.name, DB.version);

        req.onupgradeneeded = () => {
          const db = req.result;
          if (!db.objectStoreNames.contains(DB.store)) {
            db.createObjectStore(DB.store);
          }
        };

        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function idbGet(key) {
      const db = await openDb();
      try {
        return await new Promise((resolve, reject) => {
          const tx = db.transaction(DB.store, "readonly");
          const store = tx.objectStore(DB.store);
          const req = store.get(key);
          req.onsuccess = () => resolve(req.result ?? null);
          req.onerror = () => reject(req.error);
        });
      } finally {
        db.close();
      }
    }

    async function idbSet(key, value) {
      const db = await openDb();
      try {
        return await new Promise((resolve, reject) => {
          const tx = db.transaction(DB.store, "readwrite");
          const store = tx.objectStore(DB.store);
          const req = store.put(value, key);
          req.onsuccess = () => resolve(true);
          req.onerror = () => reject(req.error);
        });
      } finally {
        db.close();
      }
    }

    async function idbDel(key) {
      const db = await openDb();
      try {
        return await new Promise((resolve, reject) => {
          const tx = db.transaction(DB.store, "readwrite");
          const store = tx.objectStore(DB.store);
          const req = store.delete(key);
          req.onsuccess = () => resolve(true);
          req.onerror = () => reject(req.error);
        });
      } finally {
        db.close();
      }
    }
    // ---------- Fetch Helpers ----------
    function fetchWithTimeout(url, options = {}) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), API.timeoutMs);

      return fetch(url, { ...options, signal: controller.signal })
        .finally(() => clearTimeout(id));
    }

    function authHeaders(token) {
      return {
        "Authorization": `Bearer ${token}`,
        "Content-Type": "application/json"
      };
    }

    async function safeReadText(resp) {
      try { return await resp.text(); } catch { return ""; }
    }

    // ---------- API Calls ----------
    async function validateToken(token) {
      const url = joinUrl(API.baseUrl, API.validatePath);

      const resp = await fetchWithTimeout(url, {
        method: "GET",
        headers: authHeaders(token)
      });

      if (resp.ok) return true;
      if (resp.status === 401 || resp.status === 403) return false;

      const text = await safeReadText(resp);
      throw new Error(`Token validation failed (${resp.status}): ${text || resp.statusText}`);
    }

    // Uses GET /api/budget/state as the category existence check
async function fetchState(token) {
  const url = joinUrl(API.baseUrl, API.statePath);
  const resp = await fetchWithTimeout(url, {
    method: "GET",
    headers: authHeaders(token)
  });

  if (!resp.ok) {
    if (resp.status === 401 || resp.status === 403) {
      return { authFailed: true, state: null };
    }
    const text = await safeReadText(resp);
    throw new Error(`State request failed (${resp.status}): ${text || resp.statusText}`);
  }

  const data = await resp.json().catch(() => null);
  return { authFailed: false, state: data };
}

    async function postInit(token, payload) {
  const url = joinUrl(API.baseUrl, API.initPath);
  const resp = await fetchWithTimeout(url, {
    method: "POST",
    headers: authHeaders(token),
    body: JSON.stringify(payload)
  });

  if (!resp.ok) {
    if (resp.status === 401 || resp.status === 403) {
      return { authFailed: true, result: null };
    }
    const text = await safeReadText(resp);
    throw new Error(`Init failed (${resp.status}): ${text || resp.statusText}`);
  }

  const data = await resp.json().catch(() => ({}));
  return { authFailed: false, result: data };
}


    // ---------- App State Machine (Launch Flow) ----------
    async function bootstrap() {
      setBusy(true);
      setStatus(globalStatus, "Starting…");
      hide(authView);
      hide(appView);

      const token = await idbGet(DB.tokenKey);

      if (!token) {
        setBusy(false);
        setStatus(globalStatus, "");
        return showAuth("No token found. Enter your bearer token to continue.");
      }

      try {
        setStatus(globalStatus, "Validating token…");
        const isValid = await validateToken(token);

        if (!isValid) {
          await idbDel(DB.tokenKey);
          setBusy(false);
          setStatus(globalStatus, "");
          return showAuth("Stored token is invalid or expired. Please enter a new token.", true);
        }

        setStatus(globalStatus, "Loading your data…");
        await showAppWithState(token);

        setStatus(globalStatus, "");
        setBusy(false);
      } catch (err) {
        setBusy(false);
        show(appView);
        hide(authView);

        setStatus(appStatus, `Unable to complete startup: ${err.message}`, "error");
        hide(hasCategoriesView);
        hide(noCategoriesView);
        setStatus(globalStatus, "Startup encountered an error. You can Retry.", "error");
      }
    }

    function showAuth(message, isError = false) {
      show(authView);
      hide(appView);
      setStatus(authStatus, message, isError ? "error" : "");
      tokenInput.value = "";
      tokenInput.focus();
    }

    async function showAppWithState(token) {
  show(appView);
  hide(authView);
  setStatus(appStatus, "Connected. Loading budget state…");

  hide(hasCategoriesView);
  hide(noCategoriesView);
  categoriesPreview.textContent = "";

  const result = await fetchState(token);

  if (result.authFailed) {
    await idbDel(DB.tokenKey);
    return showAuth("Your token is no longer valid. Please enter a new token.", true);
  }

  const state = result.state || {};
  if (state.initialized === false) {
    // Show init/onboarding
    hide(hasCategoriesView);
    show(noCategoriesView);
    setStatus(appStatus, "Budget not initialized.");
    return;
  }

  const categories = Array.isArray(state.categories) ? state.categories : [];

  if (categories.length > 0) {
    show(hasCategoriesView);
    hide(noCategoriesView);
    setStatus(appStatus, "Categories found.");
    categoriesPreview.textContent = JSON.stringify(categories.slice(0, 5), null, 2) +
      (categories.length > 5 ? `\n… (${categories.length - 5} more)` : "");
  } else {
    // Initialized but no active categories (edge case)
    hide(hasCategoriesView);
    show(noCategoriesView);
    setStatus(appStatus, "Initialized, but no active categories found.");
  }
}

    // ---------- Event Handlers ----------
    saveTokenBtn.addEventListener("click", async () => {
      const token = (tokenInput.value || "").trim();
      if (!token) return setStatus(authStatus, "Please enter a token.", "error");

      setBusy(true);
      setStatus(authStatus, "Validating token…");
      setStatus(globalStatus, "");

      try {
        const isValid = await validateToken(token);
        if (!isValid) {
          setBusy(false);
          return setStatus(authStatus, "Token is invalid or expired. Please try again.", "error");
        }

        await idbSet(DB.tokenKey, token);
        setStatus(authStatus, "Token saved.", "ok");

        await showAppWithState(token);

        setBusy(false);
      } catch (err) {
        setBusy(false);
        setStatus(authStatus, `Unable to validate token: ${err.message}`, "error");
      }
    });

    toggleTokenBtn.addEventListener("click", () => {
      const isPassword = tokenInput.type === "password";
      tokenInput.type = isPassword ? "text" : "password";
      toggleTokenBtn.textContent = isPassword ? "Hide" : "Show";
      tokenInput.focus();
    });

    logoutBtn.addEventListener("click", async () => {
      setBusy(true);
      await idbDel(DB.tokenKey);
      setBusy(false);
      showAuth("Logged out. Enter your bearer token to continue.");
    });

    retryBtn.addEventListener("click", async () => {
      await bootstrap();
    });

    // Optional: SW registration (safe to remove if handled elsewhere)
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker.register("./service-worker.js").catch(() => {});
      });
    }

    // Start the app
    bootstrap();
  </script>
</body>
</html>
