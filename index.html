function validateStep1() {
  const pt = (wizPeriodType.value || "").trim();
  const allowed = new Set(["daily", "weekly", "biweekly", "semi_monthly", "monthly", "quarterly"]);
  if (!allowed.has(pt)) return "Invalid period type.";

  if (periodUsesStartDate(pt)) {
    const ymd = mdyToYmd(wizStartDate.value);
    if (!ymd) return "Start Date must be MM-DD-YYYY.";
  }
  return null;
}

function validateStep2() {
  const cats = readCategoriesFromUI();
  if (cats.length < 1 || cats.length > 10) return "Please provide 1 to 10 categories.";

  const seen = new Set();
  for (const c of cats) {
    if (!c.name) return "Category name cannot be blank.";
    if (c.name.length > 64) return `Category name too long: ${c.name}`;
    if (!c.budget_dollars || !String(c.budget_dollars).trim()) return `Please enter a budget for: ${c.name}`;

    const k = c.name.toLowerCase();
    if (seen.has(k)) return `Duplicate category name: ${c.name}`;
    seen.add(k);
  }
  return null;
}

function effectiveStartDateYmd() {
  const pt = (wizPeriodType.value || "").trim();
  if (!periodUsesStartDate(pt)) return todayYMD();
  return mdyToYmd(wizStartDate.value);
}

function buildInitPayload() {
  return {
    period_type: (wizPeriodType.value || "").trim(),
    period_anchor_date: effectiveStartDateYmd(),
    categories: readCategoriesFromUI().map(c => ({
      name: c.name,
      sort_order: c.sort_order,
      budget_dollars: c.budget_dollars
    }))
  };
}

function periodLabel(pt) {
  switch (pt) {
    case "daily": return "Daily";
    case "weekly": return "Weekly";
    case "biweekly": return "Every Two Weeks";
    case "semi_monthly": return "Twice a Month";
    case "monthly": return "Monthly";
    case "quarterly": return "Quarterly";
    default: return pt || "—";
  }
}

function fmtUsdFromDollarsString(d) {
  const n = Number(d);
  if (!Number.isFinite(n)) return "—";
  return `$${n.toFixed(2)}`;
}

function renderReview() {
  const payload = buildInitPayload();

  if (wizReviewJson) {
    wizReviewJson.textContent = JSON.stringify(payload, null, 2);
  }

  const pt = payload.period_type;
  const uses = periodUsesStartDate(pt);

  const catCount = payload.categories?.length || 0;
  if (wizReviewSummary) {
    wizReviewSummary.textContent = `You’re about to initialize your budget with ${catCount} ${catCount === 1 ? "category" : "categories"}.`;
  }

  if (wizReviewPeriod) {
    wizReviewPeriod.textContent = `Period type: ${periodLabel(pt)}`;
  }

  if (wizReviewStartDate) {
    if (uses) {
      wizReviewStartDate.textContent = `Start date: ${ymdToMdy(payload.period_anchor_date)}`;
      wizReviewStartDate.classList.remove("hidden");
    } else {
      wizReviewStartDate.textContent = `Start date: Not required for ${periodLabel(pt)} budgets`;
      wizReviewStartDate.classList.remove("hidden");
    }
  }

  let total = 0;
  if (wizReviewCategories) {
    wizReviewCategories.innerHTML = "";
    for (const c of (payload.categories || [])) {
      const amt = Number(c.budget_dollars);
      if (Number.isFinite(amt)) total += amt;

      const row = document.createElement("div");
      row.className = "row";
      row.style.marginTop = "8px";
      row.style.justifyContent = "space-between";
      row.style.flexWrap = "nowrap";

      const left = document.createElement("div");
      left.textContent = c.name || "—";
      left.style.color = "var(--text)";
      left.style.fontWeight = "650";

      const right = document.createElement("div");
      right.textContent = fmtUsdFromDollarsString(c.budget_dollars);
      right.style.color = "var(--text)";
      right.style.fontVariantNumeric = "tabular-nums";

      row.appendChild(left);
      row.appendChild(right);
      wizReviewCategories.appendChild(row);
    }
  }

  if (wizReviewTotal) {
    wizReviewTotal.textContent = `Total starting budget: $${total.toFixed(2)}`;
  }
}

function initWizardDefaults() {
  if (!wizStartDate.value || wizStartDate.value === "MM-DD-YYYY") {
    wizStartDate.value = ymdToMdy(todayYMD());
  }

  if (wizCatList.children.length === 0) {
    addWizCategoryRow("Groceries", "300.00");
    addWizCategoryRow("Gas", "120.00");
  }

  updateStartDateAvailability();
  showStep(0);
}

/* ================= DASHBOARD STATE ================= */
let CURRENT_STATE = null;
let CURRENT_CATEGORIES = [];

function fmtPeriodRange(period) {
  if (!period || !period.start_ts || !period.end_ts) return "—";
  const s = String(period.start_ts).slice(0,10);
  const e = String(period.end_ts).slice(0,10);
  return `${ymdToMdy(s)} → ${ymdToMdy(e)}`;
}

function normalizeCategoriesFromState(state) {
  const arr = Array.isArray(state?.categories) ? state.categories : [];
  return arr.map(r => ({
    category_id: Number(r.category_id),
    name: String(r.name || "").trim(),
    budget_cents: Number(r.budget_cents) || 0,
    rollover_cents: Number(r.rollover_cents) || 0,
    spent_cents: Number(r.spent_cents) || 0,
    remaining_cents: Number(r.remaining_cents) || 0
  })).filter(c => c.name && Number.isFinite(c.category_id) && c.category_id > 0);
}

function renderDashboardFromState(state) {
  CURRENT_STATE = state || {};
  CURRENT_CATEGORIES = normalizeCategoriesFromState(CURRENT_STATE);

  if (periodLabelEl) periodLabelEl.textContent = fmtPeriodRange(CURRENT_STATE.period);

  if (txCategory) {
    txCategory.innerHTML = "";
    for (const c of CURRENT_CATEGORIES) {
      const opt = document.createElement("option");
      opt.value = String(c.category_id);
      opt.textContent = c.name;
      txCategory.appendChild(opt);
    }
  }

  if (catTableBody) {
    catTableBody.innerHTML = "";
    for (const c of CURRENT_CATEGORIES) {
      const tr = document.createElement("tr");

      const tdName = document.createElement("td");
      tdName.textContent = c.name;

      const tdBudget = document.createElement("td");
      tdBudget.className = "right";
      tdBudget.textContent = "$" + ((c.budget_cents + c.rollover_cents) / 100).toFixed(2);

      const tdSpent = document.createElement("td");
      tdSpent.className = "right";
      tdSpent.textContent = "$" + (c.spent_cents / 100).toFixed(2);

      const tdRem = document.createElement("td");
      tdRem.className = "right";
      tdRem.textContent = "$" + (c.remaining_cents / 100).toFixed(2);

      tr.appendChild(tdName);
      tr.appendChild(tdBudget);
      tr.appendChild(tdSpent);
      tr.appendChild(tdRem);
      catTableBody.appendChild(tr);
    }
  }
}

/* ================= APP FLOW ================= */
async function loadAppStateAndRender(token) {
  showApp("Loading…");
  hide(dashboardView);
  hide(noCategoriesView);

  const result = await fetchState(token);
  if (result.authFailed) {
    await idbDel(IDB.key);
    return showAuth("Stored token is invalid/expired. Please re-enter.", true);
  }

  const state = result.state || {};

  if (state.initialized === false) {
    show(noCategoriesView);
    setStatus(appStatus, "Budget not yet initialized.");
    initWizardDefaults();
    return;
  }

  hide(noCategoriesView);
  show(dashboardView);

  renderDashboardFromState(state);

  // Remove "Ready" status
  setStatus(appStatus, "");
}

async function refreshAll(token) {
  // Manual refresh button: refreshes state only (Recent Transactions card removed)
  setStatus(txStatus, "Refreshing…");
  try {
    const st = await fetchState(token);
    if (st.authFailed) {
      await idbDel(IDB.key);
      return showAuth("Token invalid/expired. Please re-enter.", true);
    }
    renderDashboardFromState(st.state || {});
    setStatus(txStatus, "Refreshed.", "ok");
  } catch (e) {
    setStatus(txStatus, e.message || String(e), "error");
  }
}

window.addEventListener("unhandledrejection", (ev) => {
  try {
    const msg = ev?.reason?.message || String(ev?.reason || "Unknown error");
    setStatus(globalStatus, `Error: ${msg}`, "error");
    showAuth(`Startup error: ${msg}`, true);
  } catch {}
});

async function bootstrap() {
  setBusy(true);
  setStatus(globalStatus, "Starting…");
  hide(authView);
  hide(appView);

  try {
    const label = getContribLabel();
    if (contribLabel) contribLabel.value = label;
    getOrCreateDeviceId();

    const token = await idbGet(IDB.key);

    if (!token) {
      setBusy(false);
      return showAuth("No token saved. Enter your bearer token to continue.");
    }

    setStatus(globalStatus, "Validating token…");
    const ok = await validateToken(token);
    if (!ok) {
      await idbDel(IDB.key);
      setBusy(false);
      return showAuth("Saved token is invalid or expired. Please enter a new token.", true);
    }

    await loadAppStateAndRender(token);
    setStatus(globalStatus, "");
    setBusy(false);
  } catch (e) {
    setBusy(false);
    showAuth(
      `Startup error: ${e?.message || String(e)}. If you're in Private Browsing or have storage blocked, allow site storage and reload.`,
      true
    );
  }
}

/* ================= EVENTS: AUTH ================= */
saveTokenBtn.addEventListener("click", async () => {
  const token = (tokenInput.value || "").trim();
  if (!token) return setStatus(authStatus, "Please enter a token.", "error");

  setBusy(true);
  setStatus(authStatus, "Validating token…");
  try {
    const ok = await validateToken(token);
    if (!ok) {
      setBusy(false);
      return setStatus(authStatus, "Token is invalid or expired.", "error");
    }
    await idbSet(IDB.key, token);
    setStatus(authStatus, "Token saved. Loading…", "ok");
    await loadAppStateAndRender(token);
    setBusy(false);
  } catch (e) {
    setBusy(false);
    setStatus(authStatus, `Unable to validate token: ${e.message}`, "error");
  }
});

toggleTokenBtn.addEventListener("click", () => {
  const isPw = tokenInput.type === "password";
  tokenInput.type = isPw ? "text" : "password";
  toggleTokenBtn.textContent = isPw ? "Hide" : "Show";
  tokenInput.focus();
});

logoutBtn.addEventListener("click", async () => {
  setBusy(true);
  await idbDel(IDB.key);
  setBusy(false);
  showAuth("Logged out. Enter your bearer token to continue.");
});

retryBtn.addEventListener("click", async () => {
  await bootstrap();
});

/* ================= EVENTS: CONTRIBUTOR LABEL ================= */
contribLabel.addEventListener("blur", () => {
  setContribLabel(contribLabel.value);
});

/* ================= EVENTS: DASHBOARD TRANSACTIONS ================= */
txAmount.addEventListener("blur", () => { txAmount.value = normalizeBudgetDisplay(txAmount.value); });

txClearBtn.addEventListener("click", () => {
  txAmount.value = "";
  txNote.value = "";
  txType.value = "expense";
  setStatus(txStatus, "", "");
});

refreshBtn.addEventListener("click", async () => {
  const token = await idbGet(IDB.key);
  if (!token) return showAuth("Missing token. Please re-enter.", true);
  setBusy(true);
  await refreshAll(token);
  setBusy(false);
});

txSubmitBtn.addEventListener("click", async () => {
  const token = await idbGet(IDB.key);
  if (!token) return showAuth("Missing token. Please re-enter.", true);

  const categoryId = Number(txCategory.value);
  if (!Number.isFinite(categoryId) || categoryId <= 0) return setStatus(txStatus, "Please choose a category.", "error");

  const cents = parseTxAmountToCents();
  if (cents === null) return setStatus(txStatus, "Enter a valid amount greater than $0.00.", "error");

  const type = String(txType.value || "expense");
  const isRefund = type === "refund";

  const note = String(txNote.value || "").trim().slice(0, 240) || undefined;

  const created_by_label = getContribLabel() || undefined;
  const device_id = getOrCreateDeviceId();
  const client_ts = Date.now();
  const client_tx_id = `${device_id}_${client_ts}_${Math.random().toString(16).slice(2)}`;

  const body = {
    created_by_label,
    items: [
      {
        category_id: categoryId,
        amount_cents: cents,
        is_refund: isRefund,
        note,
        device_id,
        client_ts,
        client_tx_id
      }
    ]
  };

  setBusy(true);
  setStatus(txStatus, "Saving…");
  try {
    const res = await postTransaction(token, body);
    if (res.authFailed) {
      await idbDel(IDB.key);
      setBusy(false);
      return showAuth("Token invalid/expired. Please re-enter.", true);
    }

    renderDashboardFromState(res.result || {});
    setStatus(txStatus, "Saved.", "ok");

    txAmount.value = "";
    txNote.value = "";

    setBusy(false);
  } catch (e) {
    setBusy(false);
    setStatus(txStatus, e.message || String(e), "error");
  }
});

/* ================= EVENTS: WIZARD ================= */
wizPeriodType.addEventListener("change", updateStartDateAvailability);

wizNext1.addEventListener("click", () => {
  const err = validateStep1();
  if (err) return setStatus(wizStatus1, err, "error");
  setStatus(wizStatus1, "", "");
  showStep(1);
});

wizBack2.addEventListener("click", () => showStep(0));

wizAddCat.addEventListener("click", () => addWizCategoryRow());

wizNext2.addEventListener("click", () => {
  const err = validateStep2();
  if (err) return setStatus(wizStatus2, err, "error");
  setStatus(wizStatus2, "", "");
  renderReview();
  showStep(2);
});

wizBack3.addEventListener("click", () => showStep(1));

wizSubmit.addEventListener("click", async () => {
  const err1 = validateStep1();
  if (err1) { showStep(0); return setStatus(wizStatus1, err1, "error"); }

  const err2 = validateStep2();
  if (err2) { showStep(1); return setStatus(wizStatus2, err2, "error"); }

  const token = await idbGet(IDB.key);
  if (!token) return showAuth("Missing token. Please re-enter.", true);

  const payload = buildInitPayload();

  setBusy(true);
  setStatus(wizStatus3, "Initializing…");

  try {
    const res = await postInit(token, payload);
    if (res.authFailed) {
      await idbDel(IDB.key);
      setBusy(false);
      return showAuth("Token invalid/expired. Please re-enter.", true);
    }

    setStatus(wizStatus3, "Initialized. Loading…", "ok");

    await loadAppStateAndRender(token);
    setBusy(false);
  } catch (e) {
    setBusy(false);
    setStatus(wizStatus3, e.message, "error");
  }
});

/* ================= START ================= */
bootstrap();
</script>
</body>
</html>
