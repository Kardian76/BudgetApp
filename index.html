<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="theme-color" content="#0b1320" />
<title>Purrfect Budget</title>

<style>
:root{
  --bg0:#070b12; --bg1:#0b1320;
  --border:rgba(255,255,255,.10);
  --text:#e9eef7; --muted:rgba(233,238,247,.75);
  --danger:#ffb4b4; --ok:#b6ffcf;
  --radius:16px;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  color:var(--text);
  background:
    radial-gradient(900px 480px at 10% 0%, rgba(45,108,223,.22), transparent 60%),
    radial-gradient(720px 360px at 90% 10%, rgba(182,255,207,.10), transparent 60%),
    linear-gradient(180deg,var(--bg0),var(--bg1));
}
.wrap{max-width:1100px;margin:0 auto;padding:18px}
h1{font-size:18px;margin:0 0 10px}
.card{
  background:linear-gradient(180deg,rgba(255,255,255,.07),rgba(255,255,255,.045));
  border:1px solid var(--border);
  border-radius:var(--radius);
  padding:16px;
}
.subcard{margin-top:14px}
.hidden{display:none!important}
.row{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
label{font-size:13px;color:var(--muted);margin-top:10px;display:block}
input,select{
  width:100%;padding:10px;border-radius:12px;
  background:rgba(0,0,0,.35);color:var(--text);
  border:1px solid var(--border)
}
button{
  border:0;border-radius:12px;padding:10px 14px;
  font-weight:600;color:#fff;cursor:pointer;
  background:linear-gradient(180deg,#2d6cdf,#1f57c8)
}
button.secondary{background:rgba(255,255,255,.12)}
button.danger{background:rgba(255,180,180,.18);color:#ffd7d7}
button:disabled{opacity:.55}
.status{font-size:13px;color:var(--muted);margin-top:8px;white-space:pre-wrap}
.status.ok{color:var(--ok)} .status.error{color:var(--danger)}
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:16px}
@media(max-width:900px){.grid2{grid-template-columns:1fr}}
table{width:100%;border-collapse:collapse;margin-top:10px}
th,td{padding:6px;border-bottom:1px solid var(--border)}
th{text-align:left;font-size:13px;color:var(--muted)}
td.right{text-align:right}
.tableScroll{max-height:360px;overflow:auto}

.fab{position:fixed;right:18px;bottom:18px;z-index:50}

/* Overlay + modal */
.modalOverlay{
  position:fixed;inset:0;
  /* Slightly darker overlay so the modal reads cleanly */
  background:rgba(0,0,0,.74);
  display:flex;align-items:flex-start;justify-content:center;
  padding:18px;z-index:100;
}
.modal{
  max-width:780px;width:100%;
  max-height:calc(100vh - 36px);
  overflow:auto;
  -webkit-overflow-scrolling: touch;

  /* OPAQUE panel background so main UI does not show through */
  background: #0b1320; /* matches theme-color / bg1 */
  border:1px solid rgba(255,255,255,.14);
  border-radius:16px;
  padding:16px;

  box-shadow: 0 18px 46px rgba(0,0,0,.45);
}
.modalHeader{display:flex;justify-content:space-between;align-items:center;gap:10px}
.divider{height:1px;background:rgba(255,255,255,.10);margin:12px 0}
.small{font-size:12px;color:var(--muted)}
.reorderItem{
  display:flex;align-items:center;justify-content:space-between;
  gap:10px;padding:8px;border:1px solid rgba(255,255,255,.10);
  border-radius:12px;margin-top:8px;background:rgba(0,0,0,.18)
}
.reorderBtns{display:flex;gap:8px;flex:0 0 auto}
.reorderBtns button{padding:8px 10px}
</style>
</head>
<body>
<div class="wrap">
  <h1>Purrfect Budget</h1>

  <!-- AUTH -->
  <div id="authView" class="card hidden">
    <label>Your name</label>
    <input id="userNameInput" placeholder="e.g. Alex" autocomplete="off" />
    <label>Bearer token</label>
    <input id="tokenInput" type="password" autocomplete="off" />
    <div class="row">
      <button id="saveTokenBtn" type="button">Continue</button>
      <button id="toggleTokenBtn" class="secondary" type="button">Show</button>
    </div>
    <div id="authStatus" class="status"></div>
  </div>

  <!-- SETUP WIZARD -->
  <div id="noCategoriesView" class="hidden">
    <div id="wizStep1" class="card">
      <h1>Step 1 — Budget period</h1>

      <label>Period type</label>
      <select id="wizPeriodType">
        <option value="daily">Daily</option>
        <option value="weekly">Weekly</option>
        <option value="biweekly" selected>Every Two Weeks</option>
        <option value="semi_monthly">Twice a Month</option>
        <option value="monthly">Monthly</option>
        <option value="quarterly">Quarterly</option>
      </select>

      <p class="status" style="margin-top:6px;">
        Budgets reset automatically at the start of each period.
      </p>

      <label>Start date (MM-DD-YYYY)</label>
      <input id="wizStartDate" placeholder="MM-DD-YYYY" inputmode="numeric" />

      <div class="row">
        <button id="wizNext1" type="button">Next</button>
      </div>
      <div id="wizStatus1" class="status"></div>
    </div>

    <div id="wizStep2" class="card hidden">
      <h1>Step 2 — Categories</h1>
      <div id="wizCatList"></div>
      <div class="row">
        <button id="wizAddCat" class="secondary" type="button">Add Category</button>
        <button id="wizNext2" type="button">Next</button>
      </div>
      <div id="wizStatus2" class="status"></div>
    </div>

    <div id="wizStep3" class="card hidden">
      <h1>Step 3 — Confirm</h1>
      <div id="wizReview" class="status"></div>
      <div class="row">
        <button id="wizSubmit" type="button">Initialize Budget</button>
      </div>
      <div id="wizStatus3" class="status"></div>
    </div>
  </div>

  <!-- APP -->
  <div id="appView" class="hidden">
    <div id="dashboardView" class="hidden">

      <div class="card">
        <h1>Budget Summary</h1>
        <div class="status">Period: <strong id="periodLabel">—</strong></div>

        <div class="tableScroll">
          <table>
            <thead>
              <tr>
                <th>Category</th>
                <th class="right">Spent</th>
                <th class="right">Remaining</th>
              </tr>
            </thead>
            <tbody id="catTableBody"></tbody>
          </table>
        </div>
      </div>

      <div class="grid2">
        <div class="card subcard">
          <h1>Add Transaction</h1>

          <label>Type</label>
          <select id="txType">
            <option value="expense">Expense</option>
            <option value="refund">Refund</option>
          </select>

          <label>Category</label>
          <select id="txCategory"></select>

          <label>Amount</label>
          <input id="txAmount" placeholder="$0.00" inputmode="decimal" />

          <label>Note</label>
          <input id="txNote" />

          <div class="row">
            <button id="txSubmitBtn" type="button">Save</button>
          </div>
          <div id="txStatus" class="status"></div>
        </div>
      </div>
    </div>
  </div>

  <button id="openSettingsBtn" class="fab" type="button">Settings</button>
  <div id="globalStatus" class="status"></div>
</div>

<!-- SETTINGS MODAL -->
<div id="settingsOverlay" class="modalOverlay hidden" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true">
    <div class="modalHeader">
      <h1 style="margin:0;">Settings</h1>
      <button id="settingsCloseBtn" class="secondary" type="button">Close</button>
    </div>

    <div class="divider"></div>

    <div class="card">
      <h1>Budget Categories</h1>
      <div class="row">
        <button id="settingsOpenReorderBtn" class="secondary" type="button">Reorder Budget Categories</button>
      </div>

      <div id="settingsReorderPanel" class="subcard hidden">
        <div class="status" style="margin-top:0;">
          Move categories up/down. This affects how categories are shown in the app on this device.
        </div>
        <div id="settingsReorderList"></div>
        <div class="row">
          <button id="settingsSaveOrderBtn" type="button">Save Order</button>
          <button id="settingsCancelOrderBtn" class="secondary" type="button">Cancel</button>
        </div>
        <div id="settingsReorderStatus" class="status"></div>
      </div>
    </div>

    <div class="card subcard">
      <h1>Account</h1>
      <div class="row">
        <button id="settingsLogoutBtn" class="secondary" type="button">Log Out</button>
        <button id="settingsResetBtn" class="danger" type="button">Reset Budget</button>
      </div>
      <div class="small" style="margin-top:8px;">
        Reset clears categories, budgets, and all transaction history from the server.
      </div>
      <div id="settingsAccountStatus" class="status"></div>
    </div>
  </div>
</div>
<script>
/* ================= CONFIG ================= */
const API = {
  base: "https://purrfect-budget-api.kardian.workers.dev",
  validate: "/api/auth/validate",
  state: "/api/budget/state",
  init: "/api/budget/init",
  tx: "/api/budget/transactions",
  reset: "/api/budget/reset",
  timeoutMs: 12000
};

/* ================= DOM ================= */
const $ = (id) => document.getElementById(id);

const authView = $("authView");
const userNameInput = $("userNameInput");
const tokenInput = $("tokenInput");
const saveTokenBtn = $("saveTokenBtn");
const toggleTokenBtn = $("toggleTokenBtn");
const authStatus = $("authStatus");

const noCategoriesView = $("noCategoriesView");
const wizStep1 = $("wizStep1");
const wizStep2 = $("wizStep2");
const wizStep3 = $("wizStep3");
const wizPeriodType = $("wizPeriodType");
const wizStartDate = $("wizStartDate");
const wizCatList = $("wizCatList");
const wizReview = $("wizReview");
const wizNext1 = $("wizNext1");
const wizAddCat = $("wizAddCat");
const wizNext2 = $("wizNext2");
const wizSubmit = $("wizSubmit");
const wizStatus1 = $("wizStatus1");
const wizStatus2 = $("wizStatus2");
const wizStatus3 = $("wizStatus3");

const appView = $("appView");
const dashboardView = $("dashboardView");
const periodLabel = $("periodLabel");
const catTableBody = $("catTableBody");

const txType = $("txType");
const txCategory = $("txCategory");
const txAmount = $("txAmount");
const txNote = $("txNote");
const txSubmitBtn = $("txSubmitBtn");
const txStatus = $("txStatus");

const globalStatus = $("globalStatus");

const openSettingsBtn = $("openSettingsBtn");
const settingsOverlay = $("settingsOverlay");
const settingsCloseBtn = $("settingsCloseBtn");

const settingsOpenReorderBtn = $("settingsOpenReorderBtn");
const settingsReorderPanel = $("settingsReorderPanel");
const settingsReorderList = $("settingsReorderList");
const settingsSaveOrderBtn = $("settingsSaveOrderBtn");
const settingsCancelOrderBtn = $("settingsCancelOrderBtn");
const settingsReorderStatus = $("settingsReorderStatus");

const settingsLogoutBtn = $("settingsLogoutBtn");
const settingsResetBtn = $("settingsResetBtn");
const settingsAccountStatus = $("settingsAccountStatus");

/* ================= UI HELPERS ================= */
function show(el){ if (el) el.classList.remove("hidden"); }
function hide(el){ if (el) el.classList.add("hidden"); }

function setStatus(el, msg, kind){
  if (!el) return;
  el.textContent = msg || "";
  el.classList.remove("ok","error");
  if (kind) el.classList.add(kind);
}

function join(path){
  return API.base.replace(/\/+$/,"") + "/" + path.replace(/^\/+/,"");
}

function authHeaders(token){
  return { Authorization:`Bearer ${token}`, "Content-Type":"application/json" };
}

function fetchWithTimeout(url, options = {}){
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), API.timeoutMs);
  return fetch(url, { ...options, signal: controller.signal }).finally(() => clearTimeout(id));
}

async function safeText(resp){
  try { return await resp.text(); } catch { return ""; }
}

/* ================= INDEXEDDB (ROBUST) ================= */
const IDB = { name:"pwa-budget-app", version:4, store:"kv" };
const KEY_TOKEN = "token";
const KEY_NAME  = "name";
const KEY_CAT_ORDER = "catOrder"; // array of category_id numbers in desired UI order

function deleteDb(){
  return new Promise((resolve) => {
    const del = indexedDB.deleteDatabase(IDB.name);
    del.onsuccess = () => resolve(true);
    del.onerror = () => resolve(false);
    del.onblocked = () => resolve(false);
  });
}

function openDbOnce(versionOverride){
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(IDB.name, versionOverride ?? IDB.version);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(IDB.store)) db.createObjectStore(IDB.store);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function openDb(){
  try {
    const db = await openDbOnce();
    if (!db.objectStoreNames.contains(IDB.store)) {
      db.close();
      await deleteDb();
      return await openDbOnce();
    }
    return db;
  } catch (e) {
    const msg = String(e?.message || e || "");
    if (msg.includes("higher version")) {
      await deleteDb();
      return await openDbOnce();
    }
    throw e;
  }
}

async function idbGet(key){
  const db = await openDb();
  try {
    return await new Promise((resolve, reject) => {
      const tx = db.transaction(IDB.store, "readonly");
      const store = tx.objectStore(IDB.store);
      const req = store.get(key);
      req.onsuccess = () => resolve(req.result ?? null);
      req.onerror = () => reject(req.error);
    });
  } finally { db.close(); }
}

async function idbSet(key, value){
  const db = await openDb();
  try {
    return await new Promise((resolve, reject) => {
      const tx = db.transaction(IDB.store, "readwrite");
      const store = tx.objectStore(IDB.store);
      const req = store.put(value, key);
      req.onsuccess = () => resolve(true);
      req.onerror = () => reject(req.error);
    });
  } finally { db.close(); }
}

async function idbDel(key){
  const db = await openDb();
  try {
    return await new Promise((resolve, reject) => {
      const tx = db.transaction(IDB.store, "readwrite");
      const store = tx.objectStore(IDB.store);
      const req = store.delete(key);
      req.onsuccess = () => resolve(true);
      req.onerror = () => reject(req.error);
    });
  } finally { db.close(); }
}

/* ================= API ================= */
async function validateToken(token){
  const url = join(API.validate);
  const resp = await fetchWithTimeout(url, { method:"GET", headers: authHeaders(token) });
  if (resp.ok) return true;
  if (resp.status === 401 || resp.status === 403) return false;
  const t = await safeText(resp);
  throw new Error(`Token validate failed (${resp.status}): ${t || resp.statusText}`);
}

async function fetchState(token){
  const url = join(API.state);
  const resp = await fetchWithTimeout(url, { method:"GET", headers: authHeaders(token) });
  if (!resp.ok){
    if (resp.status === 401 || resp.status === 403) return { authFailed:true, state:null };
    const t = await safeText(resp);
    throw new Error(`State failed (${resp.status}): ${t || resp.statusText}`);
  }
  return { authFailed:false, state: await resp.json().catch(()=> ({})) };
}

async function postInit(token, payload){
  const url = join(API.init);
  const resp = await fetchWithTimeout(url, { method:"POST", headers: authHeaders(token), body: JSON.stringify(payload) });
  if (!resp.ok){
    if (resp.status === 401 || resp.status === 403) return { authFailed:true, result:null };
    const t = await safeText(resp);
    throw new Error(`Init failed (${resp.status}): ${t || resp.statusText}`);
  }
  return { authFailed:false, result: await resp.json().catch(()=> ({})) };
}

async function postTransaction(token, payload){
  const url = join(API.tx);
  const resp = await fetchWithTimeout(url, { method:"POST", headers: authHeaders(token), body: JSON.stringify(payload) });
  if (!resp.ok){
    if (resp.status === 401 || resp.status === 403) return { authFailed:true, result:null };
    const t = await safeText(resp);
    throw new Error(`Transaction failed (${resp.status}): ${t || resp.statusText}`);
  }
  return { authFailed:false, result: await resp.json().catch(()=> ({})) };
}

async function postReset(token){
  const url = join(API.reset);
  const resp = await fetchWithTimeout(url, {
    method:"POST",
    headers: authHeaders(token),
    body: JSON.stringify({ confirm:"RESET" })
  });
  if (!resp.ok){
    if (resp.status === 401 || resp.status === 403) return { authFailed:true, result:null };
    const t = await safeText(resp);
    throw new Error(`Reset failed (${resp.status}): ${t || resp.statusText}`);
  }
  return { authFailed:false, result: await resp.json().catch(()=> ({})) };
}

/* ================= DATE + MONEY ================= */
const pad2 = (n) => String(n).padStart(2, "0");

function todayYMD(){
  const d = new Date();
  return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
}

function ymdToMdy(ymd){
  const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(String(ymd||""));
  if (!m) return "";
  return `${m[2]}-${m[3]}-${m[1]}`;
}

function mdyToYmd(mdy){
  const s = String(mdy||"").trim();
  const m = /^(\d{2})-(\d{2})-(\d{4})$/.exec(s);
  if (!m) return null;
  const mm = Number(m[1]), dd = Number(m[2]), yyyy = Number(m[3]);
  if (yyyy < 1900 || yyyy > 2100) return null;
  const dt = new Date(yyyy, mm-1, dd);
  if (dt.getFullYear() !== yyyy || dt.getMonth() !== (mm-1) || dt.getDate() !== dd) return null;
  return `${yyyy}-${pad2(mm)}-${pad2(dd)}`;
}

function normalizeMoneyDisplay(s){
  const raw = String(s||"").trim().replace(/[^0-9.]/g,"");
  if (!raw) return "";
  const n = Number(raw);
  if (!Number.isFinite(n)) return "";
  return "$" + n.toFixed(2);
}

function dollarsToCentsFromInput(s){
  const raw = String(s||"").trim().replace(/[^0-9.]/g,"");
  if (!raw) return null;
  const n = Number(raw);
  if (!Number.isFinite(n) || n <= 0) return null;
  return Math.round(n*100);
}

function fmtCents(c){
  const n = Number(c);
  if (!Number.isFinite(n)) return "—";
  return "$" + (n/100).toFixed(2);
}

/* ================= WIZARD ================= */
function showWizardStep(n){
  [wizStep1, wizStep2, wizStep3].forEach((el, idx) => el.classList.toggle("hidden", idx !== n));
}

function addWizRow(name = "", budget = ""){
  const wrap = document.createElement("div");
  wrap.className = "row";
  wrap.style.marginTop = "10px";
  wrap.innerHTML = `
    <input class="wizCatName" placeholder="Category" value="${String(name).replaceAll('"','&quot;')}" />
    <input class="wizCatBudget" placeholder="$0.00" value="${String(budget).replaceAll('"','&quot;')}" inputmode="decimal" />
    <button type="button" class="secondary wizRemoveBtn">Remove</button>
  `;
  const b = wrap.querySelector(".wizCatBudget");
  b.addEventListener("blur", () => { b.value = normalizeMoneyDisplay(b.value); });
  wrap.querySelector(".wizRemoveBtn").addEventListener("click", () => wrap.remove());
  wizCatList.appendChild(wrap);
}

function initWizard(){
  wizCatList.innerHTML = "";
  wizStartDate.value = ymdToMdy(todayYMD());
  addWizRow("Groceries", "300.00");
  addWizRow("Gas", "120.00");
  setStatus(wizStatus1, "");
  setStatus(wizStatus2, "");
  setStatus(wizStatus3, "");
  wizReview.textContent = "";
  showWizardStep(0);
}

function readWizardCategories(){
  const rows = Array.from(wizCatList.querySelectorAll(".row"));
  const cats = [];
  for (const r of rows){
    const name = (r.querySelector(".wizCatName")?.value || "").trim();
    const money = (r.querySelector(".wizCatBudget")?.value || "").trim();
    const dollars = money.replace(/[^0-9.]/g,"");
    if (!name) continue;
    cats.push({ name, sort_order: cats.length + 1, budget_dollars: dollars });
  }
  return cats;
}

function validateWizardStep1(){
  const pt = String(wizPeriodType.value || "").trim();
  const allowed = new Set(["daily","weekly","biweekly","semi_monthly","monthly","quarterly"]);
  if (!allowed.has(pt)) return "Invalid period type.";
  const ymd = mdyToYmd(wizStartDate.value);
  if (!ymd) return "Start date must be MM-DD-YYYY.";
  return null;
}

function validateWizardStep2(){
  const cats = readWizardCategories();
  if (cats.length < 1 || cats.length > 10) return "Please provide 1 to 10 categories.";
  const seen = new Set();
  for (const c of cats){
    if (!c.name) return "Category name cannot be blank.";
    if (!c.budget_dollars) return `Please enter a budget for: ${c.name}`;
    const k = c.name.toLowerCase();
    if (seen.has(k)) return `Duplicate category name: ${c.name}`;
    seen.add(k);
  }
  return null;
}

function renderWizardReview(){
  const pt = String(wizPeriodType.value || "").trim();
  const cats = readWizardCategories();
  let total = 0;

  const lines = [];
  lines.push(`Period type: ${pt}`);
  lines.push(`Start date: ${wizStartDate.value}`);
  lines.push(`Categories (${cats.length}):`);
  for (const c of cats){
    const n = Number(c.budget_dollars);
    if (Number.isFinite(n)) total += n;
    lines.push(`• ${c.name}: $${Number(c.budget_dollars || 0).toFixed(2)}`);
  }
  lines.push(`Total starting budget: $${total.toFixed(2)}`);
  wizReview.textContent = lines.join("\n");
}

async function submitInit(){
  const err1 = validateWizardStep1();
  if (err1){ showWizardStep(0); return setStatus(wizStatus1, err1, "error"); }
  const err2 = validateWizardStep2();
  if (err2){ showWizardStep(1); return setStatus(wizStatus2, err2, "error"); }

  const token = await idbGet(KEY_TOKEN);
  if (!token) return showAuth("Missing token. Please re-enter.", true);

  const payload = {
    period_type: String(wizPeriodType.value || "").trim(),
    period_anchor_date: mdyToYmd(wizStartDate.value),
    categories: readWizardCategories()
  };

  setStatus(wizStatus3, "Initializing…");
  try {
    const res = await postInit(token, payload);
    if (res.authFailed){
      await idbDel(KEY_TOKEN);
      return showAuth("Token invalid/expired. Please re-enter.", true);
    }
    setStatus(wizStatus3, "Initialized. Loading…", "ok");
    await bootstrap();
  } catch (e) {
    setStatus(wizStatus3, e?.message || String(e), "error");
  }
}

/* ================= AUTH/UI FLOW ================= */
function showAuth(message = "", isError = false){
  show(authView);
  hide(appView);
  hide(noCategoriesView);
  setStatus(authStatus, message, isError ? "error" : "");
  setStatus(globalStatus, "");
  userNameInput?.focus();
}

function showApp(){
  hide(authView);
  show(appView);
}

/* ================= CATEGORY ORDERING (UI ONLY) ================= */
function normalizeCategories(state){
  const cats = Array.isArray(state?.categories) ? state.categories : [];
  return cats.map(c => ({
    category_id: Number(c.category_id),
    name: String(c.name || ""),
    spent_cents: Number(c.spent_cents) || 0,
    remaining_cents: Number(c.remaining_cents) || 0
  })).filter(c => Number.isFinite(c.category_id) && c.category_id > 0 && c.name);
}

async function applyUiOrder(cats){
  const saved = await idbGet(KEY_CAT_ORDER);
  if (!Array.isArray(saved) || saved.length === 0) return cats;

  const order = saved.map(Number).filter(n => Number.isFinite(n) && n > 0);
  const byId = new Map(cats.map(c => [c.category_id, c]));

  const out = [];
  for (const id of order){
    if (byId.has(id)) out.push(byId.get(id));
  }
  for (const c of cats){
    if (!order.includes(c.category_id)) out.push(c);
  }
  return out;
}

async function ensureOrderDefaults(cats){
  const saved = await idbGet(KEY_CAT_ORDER);
  if (Array.isArray(saved) && saved.length) return;
  await idbSet(KEY_CAT_ORDER, cats.map(c => c.category_id));
}

/* ================= DASHBOARD ================= */
async function renderDashboard(state){
  const p = state?.period;
  if (p?.start_ts && p?.end_ts) {
    periodLabel.textContent = `${String(p.start_ts).slice(0,10)} → ${String(p.end_ts).slice(0,10)}`;
  } else {
    periodLabel.textContent = "—";
  }

  let cats = normalizeCategories(state);
  await ensureOrderDefaults(cats);
  cats = await applyUiOrder(cats);

  catTableBody.innerHTML = "";
  for (const c of cats){
    const tr = document.createElement("tr");

    const tdName = document.createElement("td");
    tdName.textContent = c.name;

    const tdSpent = document.createElement("td");
    tdSpent.className = "right";
    tdSpent.textContent = fmtCents(c.spent_cents);

    const tdRem = document.createElement("td");
    tdRem.className = "right";
    tdRem.textContent = fmtCents(c.remaining_cents);

    tr.appendChild(tdName);
    tr.appendChild(tdSpent);
    tr.appendChild(tdRem);
    catTableBody.appendChild(tr);
  }

  txCategory.innerHTML = "";
  for (const c of cats){
    const opt = document.createElement("option");
    opt.value = String(c.category_id);
    opt.textContent = c.name;
    txCategory.appendChild(opt);
  }
}

/* ================= SETTINGS MODAL ================= */
function openSettings(){
  settingsOverlay.classList.remove("hidden");
  settingsOverlay.setAttribute("aria-hidden", "false");
  setStatus(settingsAccountStatus, "");
  setStatus(settingsReorderStatus, "");
  hide(settingsReorderPanel);
}

function closeSettings(){
  settingsOverlay.classList.add("hidden");
  settingsOverlay.setAttribute("aria-hidden", "true");
}

let CURRENT_STATE = null;

async function openReorderPanel(){
  if (!CURRENT_STATE) return setStatus(settingsReorderStatus, "No budget loaded yet.", "error");

  let cats = normalizeCategories(CURRENT_STATE);
  await ensureOrderDefaults(cats);
  cats = await applyUiOrder(cats);

  settingsReorderList.innerHTML = "";
  for (let i = 0; i < cats.length; i++){
    const c = cats[i];
    const item = document.createElement("div");
    item.className = "reorderItem";
    item.dataset.id = String(c.category_id);

    const left = document.createElement("div");
    left.textContent = c.name;

    const btns = document.createElement("div");
    btns.className = "reorderBtns";

    const up = document.createElement("button");
    up.type = "button";
    up.className = "secondary";
    up.textContent = "Up";
    up.disabled = i === 0;
    up.addEventListener("click", () => {
      const prev = item.previousElementSibling;
      if (prev) settingsReorderList.insertBefore(item, prev);
      refreshReorderButtons();
    });

    const down = document.createElement("button");
    down.type = "button";
    down.className = "secondary";
    down.textContent = "Down";
    down.disabled = i === cats.length - 1;
    down.addEventListener("click", () => {
      const next = item.nextElementSibling;
      if (next) settingsReorderList.insertBefore(next, item);
      refreshReorderButtons();
    });

    btns.appendChild(up);
    btns.appendChild(down);

    item.appendChild(left);
    item.appendChild(btns);
    settingsReorderList.appendChild(item);
  }

  function refreshReorderButtons(){
    const items = Array.from(settingsReorderList.children);
    for (let idx = 0; idx < items.length; idx++){
      const it = items[idx];
      const [upBtn, downBtn] = it.querySelectorAll("button");
      if (upBtn) upBtn.disabled = idx === 0;
      if (downBtn) downBtn.disabled = idx === items.length - 1;
    }
  }

  refreshReorderButtons();
  show(settingsReorderPanel);
  setStatus(settingsReorderStatus, "");
}

async function saveReorder(){
  const ids = Array.from(settingsReorderList.children)
    .map(el => Number(el.dataset.id))
    .filter(n => Number.isFinite(n) && n > 0);

  if (ids.length < 1) return setStatus(settingsReorderStatus, "No categories to save.", "error");

  await idbSet(KEY_CAT_ORDER, ids);
  setStatus(settingsReorderStatus, "Saved.", "ok");

  await renderDashboard(CURRENT_STATE);
}

/* ================= BOOTSTRAP ================= */
async function loadAppStateAndRender(token){
  showApp();
  hide(dashboardView);
  hide(noCategoriesView);

  const result = await fetchState(token);
  if (result.authFailed){
    await idbDel(KEY_TOKEN);
    return showAuth("Stored token is invalid/expired. Please re-enter.", true);
  }

  const state = result.state || {};
  if (state.initialized === false){
    show(noCategoriesView);
    initWizard();
    CURRENT_STATE = null;
    return;
  }

  CURRENT_STATE = state;

  show(dashboardView);
  await renderDashboard(state);
}

async function bootstrap(){
  setStatus(globalStatus, "Starting…");

  const token = await idbGet(KEY_TOKEN);
  const name = await idbGet(KEY_NAME);

  if (!token){
    userNameInput.value = name || "";
    setStatus(globalStatus, "");
    return showAuth("No token saved. Enter your name and bearer token to continue.");
  }

  try {
    setStatus(globalStatus, "Validating token…");
    const ok = await validateToken(token);
    if (!ok){
      await idbDel(KEY_TOKEN);
      setStatus(globalStatus, "");
      return showAuth("Saved token is invalid or expired. Please enter a new token.", true);
    }
    await loadAppStateAndRender(token);
    setStatus(globalStatus, "");
  } catch (e) {
    setStatus(globalStatus, "");
    showAuth(`Startup error: ${e?.message || String(e)}`, true);
  }
}

/* ================= EVENTS: AUTH ================= */
saveTokenBtn.addEventListener("click", async () => {
  const token = (tokenInput.value || "").trim();
  const name = (userNameInput.value || "").trim();
  if (!name) return setStatus(authStatus, "Please enter your name.", "error");
  if (!token) return setStatus(authStatus, "Please enter a token.", "error");

  setStatus(authStatus, "Validating token…");
  try {
    const ok = await validateToken(token);
    if (!ok) return setStatus(authStatus, "Token is invalid or expired.", "error");

    await idbSet(KEY_NAME, name);
    await idbSet(KEY_TOKEN, token);

    setStatus(authStatus, "Saved. Loading…", "ok");
    await loadAppStateAndRender(token);
  } catch (e) {
    setStatus(authStatus, `Unable to validate token: ${e?.message || String(e)}`, "error");
  }
});

toggleTokenBtn.addEventListener("click", () => {
  const isPw = tokenInput.type === "password";
  tokenInput.type = isPw ? "text" : "password";
  toggleTokenBtn.textContent = isPw ? "Hide" : "Show";
  tokenInput.focus();
});

/* ================= EVENTS: WIZARD ================= */
wizNext1.addEventListener("click", () => {
  const err = validateWizardStep1();
  if (err) return setStatus(wizStatus1, err, "error");
  setStatus(wizStatus1, "");
  showWizardStep(1);
});

wizAddCat.addEventListener("click", () => addWizRow());

wizNext2.addEventListener("click", () => {
  const err = validateWizardStep2();
  if (err) return setStatus(wizStatus2, err, "error");
  setStatus(wizStatus2, "");
  renderWizardReview();
  showWizardStep(2);
});

wizSubmit.addEventListener("click", submitInit);

/* ================= EVENTS: TRANSACTIONS ================= */
txAmount.addEventListener("blur", () => { txAmount.value = normalizeMoneyDisplay(txAmount.value); });

txSubmitBtn.addEventListener("click", async () => {
  const token = await idbGet(KEY_TOKEN);
  const name = await idbGet(KEY_NAME);

  if (!token) return showAuth("Missing token. Please re-enter.", true);
  if (!name) return showAuth("Missing name. Please re-enter.", true);

  const categoryId = Number(txCategory.value);
  if (!Number.isFinite(categoryId) || categoryId <= 0) return setStatus(txStatus, "Please choose a category.", "error");

  const cents = dollarsToCentsFromInput(txAmount.value);
  if (cents === null) return setStatus(txStatus, "Enter a valid amount greater than $0.00.", "error");

  const isRefund = String(txType.value || "expense") === "refund";
  const note = String(txNote.value || "").trim().slice(0, 240) || undefined;

  const body = {
    created_by_label: name,
    items: [{ category_id: categoryId, amount_cents: cents, is_refund: isRefund, note }]
  };

  setStatus(txStatus, "Saving…");
  try {
    const res = await postTransaction(token, body);
    if (res.authFailed){
      await idbDel(KEY_TOKEN);
      return showAuth("Token invalid/expired. Please re-enter.", true);
    }
    CURRENT_STATE = res.result || {};
    await renderDashboard(CURRENT_STATE);
    setStatus(txStatus, "Saved.", "ok");
    txAmount.value = "";
    txNote.value = "";
  } catch (e) {
    setStatus(txStatus, e?.message || String(e), "error");
  }
});

/* ================= EVENTS: SETTINGS ================= */
openSettingsBtn.addEventListener("click", openSettings);
settingsCloseBtn.addEventListener("click", closeSettings);

settingsOverlay.addEventListener("click", (e) => {
  if (e.target === settingsOverlay) closeSettings();
});

settingsOpenReorderBtn.addEventListener("click", async () => {
  await openReorderPanel();
});

settingsCancelOrderBtn.addEventListener("click", () => {
  hide(settingsReorderPanel);
  setStatus(settingsReorderStatus, "");
});

settingsSaveOrderBtn.addEventListener("click", async () => {
  await saveReorder();
});

settingsLogoutBtn.addEventListener("click", async () => {
  await idbDel(KEY_TOKEN);
  await idbDel(KEY_NAME);
  await idbDel(KEY_CAT_ORDER);
  closeSettings();
  showAuth("Logged out. Enter your name and bearer token to continue.");
});

settingsResetBtn.addEventListener("click", async () => {
  const token = await idbGet(KEY_TOKEN);
  if (!token) return showAuth("Missing token. Please re-enter.", true);

  const ok = window.confirm("This will DELETE all categories, budgets, and transactions from the server. Continue?");
  if (!ok) return;

  setStatus(settingsAccountStatus, "Resetting…");
  try {
    const res = await postReset(token);
    if (res.authFailed){
      await idbDel(KEY_TOKEN);
      closeSettings();
      return showAuth("Token invalid/expired. Please re-enter.", true);
    }

    await idbDel(KEY_CAT_ORDER);

    setStatus(settingsAccountStatus, "Reset complete.", "ok");
    closeSettings();

    await loadAppStateAndRender(token);
  } catch (e) {
    setStatus(settingsAccountStatus, e?.message || String(e), "error");
  }
});

/* Safety: surface unhandled rejections */
window.addEventListener("unhandledrejection", (ev) => {
  const msg = ev?.reason?.message || String(ev?.reason || "Unknown error");
  setStatus(globalStatus, `Error: ${msg}`, "error");
});

/* ================= START ================= */
bootstrap();
</script>
</body>
</html>
