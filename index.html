<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Budget Tracker</title>

<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

<!-- PWA -->
<meta name="theme-color" content="#2563eb">
<link rel="manifest" href="./manifest.webmanifest?v=2026-01-13-1">

<!-- iOS + legacy Android -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="Budget">
<meta name="apple-mobile-web-app-status-bar-style" content="default">

<!-- iOS home screen icons -->
<link rel="apple-touch-icon" sizes="180x180" href="./Icon_192.png">
<link rel="apple-touch-icon" sizes="167x167" href="./Icon_192.png">
<link rel="apple-touch-icon" sizes="152x152" href="./Icon_192.png">
<link rel="apple-touch-icon" sizes="120x120" href="./Icon_192.png">

<link rel="icon" href="data:,">

<style>
:root {
  --bg-color: #f4f6f9;
  --card-bg: #ffffff;
  --card-accent: #eef2ff;
  --primary: #2563eb;
  --primary-hover: #1d4ed8;
  --text-main: #111827;
  --text-muted: #6b7280;
  --border-color: #e5e7eb;
  --success: #16a34a;
  --warning: #b45309;
  --danger: #b91c1c;

  --safe-top: env(safe-area-inset-top, 0px);
  --safe-right: env(safe-area-inset-right, 0px);
  --safe-bottom: env(safe-area-inset-bottom, 0px);
  --safe-left: env(safe-area-inset-left, 0px);

  --tap-min: 54px;
}

* { box-sizing: border-box; }

html {
  font-size: 16px;
  -webkit-text-size-adjust: 100%;
  text-size-adjust: 100%;
}

body {
  margin: 0;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  background-color: var(--bg-color);
  color: var(--text-main);
}

.container {
  width: 100%;
  padding: calc(1.25rem + var(--safe-top))
           calc(1.25rem + var(--safe-right))
           calc(1.5rem + var(--safe-bottom))
           calc(1.25rem + var(--safe-left));
}

.header-row {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.65rem;
  margin: 0 0 1rem 0;
  flex-wrap: wrap;
}

h1 {
  margin: 0;
  font-size: 1.9rem;
  font-weight: 900;
  letter-spacing: -0.015em;
  text-align: center;
}

.card {
  background: var(--card-bg);
  border-radius: 1.1rem;
  padding: 1.25rem;
  margin-bottom: 1.25rem;
  box-shadow: 0 12px 24px rgba(0,0,0,0.06);
  border: 1px solid rgba(17,24,39,0.05);
}

.card.expenses-card {
  background: var(--card-accent);
  border: 1px solid rgba(37, 99, 235, 0.18);
}

.summary-row {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin-bottom: 0.85rem;
  font-size: 1.05rem;
}
.summary-row:last-child { margin-bottom: 0; }
.summary-row span { font-weight: 900; }

.period-end {
  margin-top: 0.85rem;
  text-align: center;
  color: var(--text-muted);
  font-size: 0.92rem;
  line-height: 1.35;
}

h2 {
  text-align: center;
  font-size: 1.15rem;
  margin: 0 0 1rem 0;
  font-weight: 900;
  letter-spacing: -0.01em;
}

.form-group-vertical {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  margin-bottom: 0.9rem;
}

input {
  width: 100%;
  min-height: 44px;
  padding: 0.6rem 0.9rem;
  font-size: 1.02rem;
  border-radius: 0.85rem;
  border: 1px solid var(--border-color);
  text-align: center;
  background: #fff;
}

input:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 6px rgba(37, 99, 235, 0.18);
}

button {
  width: 100%;
  min-height: var(--tap-min);
  padding: 0.95rem 1rem;
  font-size: 1.1rem;
  font-weight: 900;
  border-radius: 0.9rem;
  border: none;
  background-color: var(--primary);
  color: #ffffff;
  cursor: pointer;
}

button:hover:not(:disabled) { background-color: var(--primary-hover); }

button:disabled {
  background-color: #9ca3af;
  cursor: not-allowed;
}

.success-message {
  text-align: center;
  font-size: 0.95rem;
  color: var(--success);
  margin-top: 0.9rem;
  display: none;
}

.pill {
  display: inline-flex;
  align-items: center;
  padding: 0.35rem 0.85rem;
  border-radius: 999px;
  border: 1px solid var(--border-color);
  font-size: 0.95rem;
  background: #fff;
  font-weight: 800;
  white-space: nowrap;
}
.pill.online  { color: var(--success); }
.pill.offline { color: var(--warning); }
.pill.syncing { color: var(--primary); }

.toggle {
  display: flex;
  gap: 0.6rem;
  margin: 0 0 0.8rem 0;
}
.toggle button {
  width: 50%;
  min-height: 44px;
  padding: 0.65rem 0.75rem;
  font-size: 1rem;
  border-radius: 0.85rem;
  font-weight: 900;
  border: 1px solid var(--border-color);
  background: #fff;
  color: var(--text-main);
}
.toggle button.active {
  background: var(--primary);
  color: #fff;
  border-color: rgba(37, 99, 235, 0.35);
}

.modal-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(17,24,39,0.45);
  display: none;
  align-items: center;
  justify-content: center;
  padding: 1rem;
  z-index: 9999;
}

.modal {
  width: min(560px, 100%);
  background: #fff;
  border-radius: 1.1rem;
  border: 1px solid rgba(17,24,39,0.08);
  box-shadow: 0 18px 42px rgba(0,0,0,0.22);
  padding: 1.1rem;
}

.modal h3 {
  margin: 0 0 0.6rem 0;
  font-size: 1.2rem;
  font-weight: 900;
}

.modal .muted {
  color: var(--text-muted);
  font-size: 0.95rem;
  line-height: 1.35;
  margin: 0 0 0.9rem 0;
}

.modal .row {
  display: grid;
  grid-template-columns: 1fr;
  gap: 0.65rem;
  margin-bottom: 0.85rem;
}

.modal label {
  font-weight: 800;
  font-size: 0.95rem;
}

.modal input {
  min-height: 44px;
}

.modal .actions {
  display: flex;
  gap: 0.75rem;
  margin-top: 0.9rem;
}
.modal .actions button {
  min-height: 48px;
}
.modal .actions .secondary {
  background: #fff;
  color: var(--text-main);
  border: 1px solid var(--border-color);
}
.modal .actions .secondary:hover { background: #f9fafb; }

.mtd-title {
  text-align: center;
  font-size: 1.05rem;
  font-weight: 900;
  margin: 0 0 0.85rem 0;
}
.small-note {
  text-align: center;
  color: var(--text-muted);
  font-size: 0.92rem;
  margin-top: 0.65rem;
}

.footer-actions {
  margin-top: 0.25rem;
}
.footer-actions button {
  background: #fff;
  color: var(--text-main);
  border: 1px solid var(--border-color);
  box-shadow: 0 10px 22px rgba(0,0,0,0.08);
}
.footer-actions button:hover { background: #f9fafb; }
</style>
</head>

<body>
<div class="container">
  <div class="header-row">
    <h1>Budget Tracker is</h1>
    <span class="pill" id="netStatusPill">Checking…</span>
  </div>

  <div class="card">
    <div class="summary-row">
      <div>Food Remaining</div>
      <span id="foodRemaining">$0.00</span>
    </div>
    <div class="summary-row">
      <div>Fun Remaining</div>
      <span id="funRemaining">$0.00</span>
    </div>
    <div class="summary-row">
      <div>Gas Remaining</div>
      <span id="gasRemaining">$0.00</span>
    </div>

    <div class="period-end" id="periodEndsText">Period ends: —</div>
  </div>

  <div class="card expenses-card">
    <h2>Enter Expenses / Refunds</h2>

    <div class="toggle" role="tablist" aria-label="Entry type">
      <button type="button" id="modeExpenseBtn" class="active">Expense</button>
      <button type="button" id="modeRefundBtn">Refund</button>
    </div>

    <div class="form-group-vertical">
      <input type="text" inputmode="decimal" id="foodInput" placeholder="Food" autocomplete="off">
      <input type="text" inputmode="decimal" id="funInput" placeholder="Fun" autocomplete="off">
      <input type="text" inputmode="decimal" id="gasInput" placeholder="Gas" autocomplete="off">
    </div>

    <button id="submitBtn" disabled>Submit</button>
    <div id="successMsg" class="success-message">Saved</div>
  </div>

  <div class="card">
    <div class="mtd-title" id="mtdTitle">Period-to-date spent</div>

    <div class="summary-row">
      <div>Food</div>
      <span id="mtdFood">$0.00</span>
    </div>
    <div class="summary-row">
      <div>Fun</div>
      <span id="mtdFun">$0.00</span>
    </div>
    <div class="summary-row">
      <div>Gas</div>
      <span id="mtdGas">$0.00</span>
    </div>

    <div class="small-note">
      Refunds reduce “spent” totals automatically.
    </div>
  </div>

  <div class="footer-actions">
    <button id="settingsBtn" type="button">Settings</button>
  </div>
</div>

<!-- Settings Modal -->
<div class="modal-backdrop" id="settingsBackdrop" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
    <h3 id="settingsTitle">Settings</h3>
    <p class="muted" id="settingsSubtitle">
      Budget changes apply starting next period (Eastern Time) so they do not change the current period’s remaining amounts.
    </p>

    <div class="row">
      <label for="setFood">Food budget (next period)</label>
      <input id="setFood" type="text" inputmode="decimal" autocomplete="off">
    </div>

    <div class="row">
      <label for="setFun">Fun budget (next period)</label>
      <input id="setFun" type="text" inputmode="decimal" autocomplete="off">
    </div>

    <div class="row">
      <label for="setGas">Gas budget (next period)</label>
      <input id="setGas" type="text" inputmode="decimal" autocomplete="off">
    </div>

    <div class="actions">
      <button class="secondary" type="button" id="settingsCancel">Cancel</button>
      <button type="button" id="settingsSave">Save</button>
    </div>
  </div>
</div>

<script>
/* =========================================================
   CONFIG
   ========================================================= */

const API_BASE = "https://budgetapp-api.kardian.workers.dev";
const AUTH_TOKEN = "K7QvN2P9x0MZyJHcF4rW8E5U1R_AkDqB3aSXTGm6nVfLw-heCpd";
const SW_VERSION = "2026-01-13-1";

const DEFAULT_BUDGETS = { food: 500, fun: 300, gas: 200 };
const PRUNE_DAYS = 60;

const STANDARD_TZ = "America/New_York"; // Eastern Time standard

/*
  Semi-monthly budget periods in Eastern Time:
  - Period 1: 1st–14th (ends at 12:00 AM ET on the 15th)
  - Period 2: 15th–end of month (ends at 12:00 AM ET on the 1st of next month)

  Implementation detail:
  - We store occurred_at as an ISO timestamp (UTC is fine).
  - We assign periods by converting occurred_at to Eastern calendar date parts
    (year/month/day) via Intl.DateTimeFormat timeZone conversion.
  - This ensures two devices in different time zones still agree on period.
*/

/* =========================================================
   ELEMENTS / STATE
   ========================================================= */

const netStatusPill = document.getElementById('netStatusPill');

const periodEndsText = document.getElementById('periodEndsText');

const settingsBtn = document.getElementById('settingsBtn');
const settingsBackdrop = document.getElementById('settingsBackdrop');
const settingsCancel = document.getElementById('settingsCancel');
const settingsSave = document.getElementById('settingsSave');
const setFood = document.getElementById('setFood');
const setFun = document.getElementById('setFun');
const setGas = document.getElementById('setGas');
const settingsSubtitle = document.getElementById('settingsSubtitle');

const modeExpenseBtn = document.getElementById('modeExpenseBtn');
const modeRefundBtn = document.getElementById('modeRefundBtn');

const foodInput = document.getElementById('foodInput');
const funInput = document.getElementById('funInput');
const gasInput = document.getElementById('gasInput');
const submitBtn = document.getElementById('submitBtn');

const foodRemainingEl = document.getElementById('foodRemaining');
const funRemainingEl = document.getElementById('funRemaining');
const gasRemainingEl = document.getElementById('gasRemaining');

const mtdTitle = document.getElementById('mtdTitle');
const mtdFoodEl = document.getElementById('mtdFood');
const mtdFunEl = document.getElementById('mtdFun');
const mtdGasEl = document.getElementById('mtdGas');

const successMsg = document.getElementById('successMsg');

const currency = new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' });

let db = null;
let isSyncing = false;
let entryMode = "expense";

/* =========================================================
   PWA / SERVICE WORKER (silent)
   ========================================================= */

(async function initPwa() {
  try {
    if (!('serviceWorker' in navigator)) return;
    await navigator.serviceWorker.register(`./sw.js?v=${encodeURIComponent(SW_VERSION)}`);
  } catch (e) {
    console.error('SW registration failed', e);
  }
})();

/* =========================================================
   INDEXEDDB SETUP
   ========================================================= */

(function initDB(){
  const req = indexedDB.open('budgetDB', 2);
  req.onupgradeneeded = e => {
    const d = e.target.result;
    if (!d.objectStoreNames.contains('tx')) d.createObjectStore('tx', { autoIncrement: true });
    if (!d.objectStoreNames.contains('meta')) d.createObjectStore('meta', { keyPath: 'key' });
    if (!d.objectStoreNames.contains('ledger')) d.createObjectStore('ledger', { keyPath: 'client_id' });
  };
  req.onsuccess = async (e) => {
    db = e.target.result;

    await cleanupLegacyOutbox();
    await pruneLocalData(PRUNE_DAYS);
    await rollBudgetPeriodIfNeeded();
    await loadSummary();
  };
  req.onerror = () => console.error('IndexedDB error');
})();

/* =========================================================
   HELPERS
   ========================================================= */

function setNetStatus(extraLabel) {
  if (isSyncing) {
    netStatusPill.textContent = extraLabel || 'Syncing…';
    netStatusPill.className = 'pill syncing';
    return;
  }
  const online = navigator.onLine;
  netStatusPill.textContent = online ? 'Online' : 'Offline';
  netStatusPill.className = `pill ${online ? 'online' : 'offline'}`;
}

function centsFromDollars(d) { return Math.round(Number(d) * 100); }
function dollarsFromCents(c) { return (Number(c) || 0) / 100; }
function nowIso() { return new Date().toISOString(); }
function pad2(n) { return String(n).padStart(2,'0'); }

function uuid() {
  if (crypto && typeof crypto.randomUUID === "function") return crypto.randomUUID();
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

function parseDollarsFromText(s) {
  const t = String(s ?? '').trim();
  if (!t) return 0;
  const cleaned = t.replace(/\$/g,'').replace(/,/g,'');
  const n = Number(cleaned);
  return Number.isFinite(n) ? n : NaN;
}

function clampNonNegative(n) {
  return (Number.isFinite(n) && n >= 0) ? n : NaN;
}

/* =========================================================
   EASTERN TIME PERIOD LOGIC (date-parts based, DST-safe)
   ========================================================= */

const etPartsFormatter = new Intl.DateTimeFormat('en-US', {
  timeZone: STANDARD_TZ,
  year: 'numeric',
  month: '2-digit',
  day: '2-digit'
});

const etLabelFormatter = new Intl.DateTimeFormat('en-US', {
  timeZone: STANDARD_TZ,
  month: 'long',
  year: 'numeric'
});

const etMonthDayFormatter = new Intl.DateTimeFormat('en-US', {
  timeZone: STANDARD_TZ,
  month: 'long',
  day: 'numeric',
  year: 'numeric'
});

function getEtYmd(dateObj) {
  // Returns { y, m, d } in Eastern calendar terms
  const parts = etPartsFormatter.formatToParts(dateObj);
  const map = Object.fromEntries(parts.filter(p => p.type !== 'literal').map(p => [p.type, p.value]));
  return { y: Number(map.year), m: Number(map.month), d: Number(map.day) };
}

function lastDayOfMonth(y, m1to12) {
  return new Date(Date.UTC(y, m1to12, 0)).getUTCDate();
}

function periodKeyFromYmd(y, m, d) {
  const half = (d <= 14) ? 1 : 2;
  return `${y}-${pad2(m)}-${half}`;
}

function currentPeriodInfoET(now = new Date()) {
  const { y, m, d } = getEtYmd(now);
  const half = (d <= 14) ? 1 : 2;
  const last = lastDayOfMonth(y, m);

  const monthYear = etLabelFormatter.format(new Date(Date.UTC(y, m - 1, 1)));
  const label = (half === 1)
    ? `${monthYear} (1–14, ET)`
    : `${monthYear} (15–${last}, ET)`;

  // Period end at midnight ET:
  // - For half 1: midnight ET on the 15th
  // - For half 2: midnight ET on the 1st of next month
  let endY = y, endM = m, endD;
  if (half === 1) {
    endD = 15;
  } else {
    endD = 1;
    if (m === 12) { endM = 1; endY = y + 1; }
    else { endM = m + 1; }
  }

  return {
    y, m, d, half, last,
    key: `${y}-${pad2(m)}-${half}`,
    label,
    endY, endM, endD
  };
}

function nextPeriodInfoET(now = new Date()) {
  const cur = currentPeriodInfoET(now);
  // Next period is simply the other half (or next month)
  // We compute by creating a date near the start of next period in UTC,
  // then converting to ET parts again.
  //
  // For half 1 -> next starts on 15th ET
  // For half 2 -> next starts on 1st ET next month
  const approxUtc = (cur.half === 1)
    ? new Date(Date.UTC(cur.y, cur.m - 1, 15, 12, 0, 0)) // midday UTC near 15th
    : new Date(Date.UTC(cur.endY, cur.endM - 1, 1, 12, 0, 0)); // midday UTC near next 1st

  return currentPeriodInfoET(approxUtc);
}

function formatPeriodEndText(cur) {
  // Display: "Period ends: Month D, YYYY at 12:00 AM ET"
  // We create a UTC date near the ET end date, then format in ET.
  const approxUtc = new Date(Date.UTC(cur.endY, cur.endM - 1, cur.endD, 12, 0, 0));
  const dateLabel = etMonthDayFormatter.format(approxUtc);
  return `Period ends: ${dateLabel} at 12:00 AM ET`;
}

/* =========================================================
   API CALLS (Worker)
   ========================================================= */

async function apiGet(path) {
  const resp = await fetch(`${API_BASE}${path}`, {
    method: "GET",
    mode: "cors",
    cache: "no-store",
    headers: { "Authorization": `Bearer ${AUTH_TOKEN}` }
  });

  const text = await resp.text();
  let json;
  try { json = JSON.parse(text); }
  catch { throw new Error(`Non-JSON (HTTP ${resp.status})`); }

  if (!resp.ok || json?.ok === false) throw new Error(json?.error || `HTTP ${resp.status}`);
  return json;
}

async function apiHealth() {
  const resp = await fetch(`${API_BASE}/api/health`, { method: "GET", mode: "cors", cache: "no-store" });
  const text = await resp.text();
  let json;
  try { json = JSON.parse(text); }
  catch { throw new Error(`Non-JSON (HTTP ${resp.status})`); }
  if (!resp.ok || json?.ok === false) throw new Error(json?.error || `HTTP ${resp.status}`);
  return json;
}

async function apiPostJson(path, payload) {
  const resp = await fetch(`${API_BASE}${path}`, {
    method: "POST",
    mode: "cors",
    cache: "no-store",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${AUTH_TOKEN}`
    },
    body: JSON.stringify(payload),
  });

  const text = await resp.text();
  let json;
  try { json = JSON.parse(text); }
  catch { throw new Error(`Non-JSON (HTTP ${resp.status})`); }

  if (!resp.ok || json?.ok === false) throw new Error(json?.error || `HTTP ${resp.status}`);
  return json;
}

/* =========================================================
   META STORE
   ========================================================= */

function getMeta(key) {
  return new Promise((resolve, reject) => {
    if (!db) return resolve(null);
    const tx = db.transaction('meta', 'readonly');
    const req = tx.objectStore('meta').get(key);
    req.onsuccess = () => resolve(req.result ? req.result.value : null);
    req.onerror = () => reject(req.error);
  });
}

function setMeta(key, value) {
  return new Promise((resolve, reject) => {
    if (!db) return resolve();
    const tx = db.transaction('meta', 'readwrite');
    tx.objectStore('meta').put({ key, value });
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

/* =========================================================
   LEDGER
   ========================================================= */

function upsertLedgerItems(items) {
  return new Promise((resolve, reject) => {
    if (!db) return resolve();
    const tx = db.transaction('ledger', 'readwrite');
    const store = tx.objectStore('ledger');
    for (const it of items) store.put(it);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

function getAllLedger() {
  return new Promise((resolve, reject) => {
    if (!db) return resolve([]);
    const tx = db.transaction('ledger', 'readonly');
    const req = tx.objectStore('ledger').getAll();
    req.onsuccess = () => resolve(req.result || []);
    req.onerror = () => reject(req.error);
  });
}

/* =========================================================
   OUTBOX CLEANUP
   ========================================================= */

async function cleanupLegacyOutbox() {
  if (!db) return;

  const tx = db.transaction('tx', 'readwrite');
  const store = tx.objectStore('tx');

  return new Promise((resolve, reject) => {
    const req = store.openCursor();
    req.onsuccess = (e) => {
      const c = e.target.result;
      if (!c) return resolve();

      const v = c.value;
      const isValid = v && Array.isArray(v.items);
      if (!isValid) store.delete(c.key);

      c.continue();
    };
    req.onerror = () => reject(req.error);
  });
}

/* =========================================================
   PRUNING (local)
   ========================================================= */

async function pruneLocalData(days) {
  if (!db) return;

  const cutoffMs = Date.now() - (days * 24 * 60 * 60 * 1000);

  await new Promise((resolve, reject) => {
    const tx = db.transaction('ledger', 'readwrite');
    const store = tx.objectStore('ledger');
    const req = store.openCursor();

    req.onsuccess = (e) => {
      const c = e.target.result;
      if (!c) return resolve();

      const v = c.value;
      const t = Date.parse(v?.occurred_at || '');
      if (Number.isFinite(t) && t < cutoffMs) store.delete(c.key);

      c.continue();
    };
    req.onerror = () => reject(req.error);
  });

  await new Promise((resolve, reject) => {
    const tx = db.transaction('tx', 'readwrite');
    const store = tx.objectStore('tx');
    const req = store.openCursor();

    req.onsuccess = (e) => {
      const c = e.target.result;
      if (!c) return resolve();

      const batch = c.value;
      const first = batch?.items?.[0];
      const t = Date.parse(first?.occurred_at || '');
      if (Number.isFinite(t) && t < cutoffMs) store.delete(c.key);

      c.continue();
    };
    req.onerror = () => reject(req.error);
  });

  await setMeta('last_prune_iso', new Date().toISOString());
}

/* =========================================================
   BUDGETS (locked per Eastern semi-monthly period)
   ========================================================= */

async function getCurrentPeriodBudgetsCents() {
  const cur = currentPeriodInfoET(new Date());
  const storedPeriod = await getMeta('budget_period');

  if (!storedPeriod) {
    await setMeta('budget_period', cur.key);
    await setMeta('budget_food_cents', centsFromDollars(DEFAULT_BUDGETS.food));
    await setMeta('budget_fun_cents',  centsFromDollars(DEFAULT_BUDGETS.fun));
    await setMeta('budget_gas_cents',  centsFromDollars(DEFAULT_BUDGETS.gas));
  }

  return {
    period: await getMeta('budget_period'),
    food: Number(await getMeta('budget_food_cents')) || centsFromDollars(DEFAULT_BUDGETS.food),
    fun:  Number(await getMeta('budget_fun_cents'))  || centsFromDollars(DEFAULT_BUDGETS.fun),
    gas:  Number(await getMeta('budget_gas_cents'))  || centsFromDollars(DEFAULT_BUDGETS.gas),
  };
}

async function rollBudgetPeriodIfNeeded() {
  const nowKey = currentPeriodInfoET(new Date()).key;
  const storedPeriod = await getMeta('budget_period');

  if (!storedPeriod) {
    await getCurrentPeriodBudgetsCents();
    return;
  }
  if (storedPeriod === nowKey) return;

  const nextFood = await getMeta('next_budget_food_cents');
  const nextFun  = await getMeta('next_budget_fun_cents');
  const nextGas  = await getMeta('next_budget_gas_cents');

  const cur = await getCurrentPeriodBudgetsCents();

  await setMeta('budget_period', nowKey);
  await setMeta('budget_food_cents', Number(nextFood ?? cur.food));
  await setMeta('budget_fun_cents',  Number(nextFun  ?? cur.fun));
  await setMeta('budget_gas_cents',  Number(nextGas  ?? cur.gas));

  await setMeta('next_budget_food_cents', null);
  await setMeta('next_budget_fun_cents', null);
  await setMeta('next_budget_gas_cents', null);
}

/* =========================================================
   UI HELPERS
   ========================================================= */

function showSuccess(text) {
  successMsg.textContent = text || 'Saved';
  successMsg.style.display = 'block';
  setTimeout(() => { successMsg.style.display = 'none'; }, 2000);
}

function updateButtonState() {
  submitBtn.disabled = (!foodInput.value && !funInput.value && !gasInput.value);
}

function setMode(mode) {
  entryMode = mode;
  if (mode === "expense") {
    modeExpenseBtn.classList.add('active');
    modeRefundBtn.classList.remove('active');
  } else {
    modeRefundBtn.classList.add('active');
    modeExpenseBtn.classList.remove('active');
  }
}

/* =========================================================
   SUMMARY + PERIOD-TO-DATE TOTALS (Eastern semi-monthly)
   ========================================================= */

function computePeriodToDateSpentCents(ledgerItems) {
  const cur = currentPeriodInfoET(new Date());
  const spent = { food: 0, fun: 0, gas: 0 };

  for (const e of ledgerItems) {
    const t = Date.parse(e?.occurred_at || '');
    if (!Number.isFinite(t)) continue;

    // Determine ET period key for this entry from its timestamp
    const ymd = getEtYmd(new Date(t));
    const entryKey = periodKeyFromYmd(ymd.y, ymd.m, ymd.d);

    if (entryKey !== cur.key) continue;

    const k = e.category_key;
    if (k in spent) spent[k] += Number(e.amount || 0);
  }

  return spent;
}

function computeRemainingForPeriod(budgetsCents, spentCents) {
  return {
    food: budgetsCents.food - spentCents.food,
    fun:  budgetsCents.fun  - spentCents.fun,
    gas:  budgetsCents.gas  - spentCents.gas,
  };
}

function renderSummary(remainingCents) {
  foodRemainingEl.textContent = currency.format(dollarsFromCents(remainingCents.food));
  funRemainingEl.textContent  = currency.format(dollarsFromCents(remainingCents.fun));
  gasRemainingEl.textContent  = currency.format(dollarsFromCents(remainingCents.gas));

  const cur = currentPeriodInfoET(new Date());
  periodEndsText.textContent = formatPeriodEndText(cur);
}

function renderPeriodToDate(spentCents) {
  const cur = currentPeriodInfoET(new Date());
  mtdTitle.textContent = `Period-to-date spent (${cur.label})`;
  mtdFoodEl.textContent = currency.format(dollarsFromCents(spentCents.food));
  mtdFunEl.textContent  = currency.format(dollarsFromCents(spentCents.fun));
  mtdGasEl.textContent  = currency.format(dollarsFromCents(spentCents.gas));
}

async function loadSummary() {
  setNetStatus();

  await rollBudgetPeriodIfNeeded();

  let ledger = [];
  try {
    ledger = await getAllLedger();
  } catch (e) {
    console.error(e);
  }

  const budgets = await getCurrentPeriodBudgetsCents();
  const spentCents = computePeriodToDateSpentCents(ledger);
  const remainingCents = computeRemainingForPeriod(budgets, spentCents);

  renderSummary(remainingCents);
  renderPeriodToDate(spentCents);

  if (navigator.onLine) {
    try {
      await syncNow();
      ledger = await getAllLedger();

      await rollBudgetPeriodIfNeeded();

      const budgets2 = await getCurrentPeriodBudgetsCents();
      const spent2 = computePeriodToDateSpentCents(ledger);
      const rem2 = computeRemainingForPeriod(budgets2, spent2);

      renderSummary(rem2);
      renderPeriodToDate(spent2);
    } catch (e) {
      console.error(e);
    }
  }
}

/* =========================================================
   OUTBOX
   ========================================================= */

function enqueueOfflineBatch(batch) {
  if (!db) return;
  db.transaction('tx','readwrite').objectStore('tx').add(batch);
}

/* =========================================================
   SUBMIT HANDLING (offline-first)
   ========================================================= */

async function submitExpenses(foodDollars, funDollars, gasDollars) {
  // We still store an absolute timestamp; Eastern is the standard for period assignment,
  // not for how timestamps are persisted.
  const occurred_at = nowIso();
  const created_by = "pwa";

  const sign = (entryMode === "refund") ? -1 : 1;
  const items = [];

  if (foodDollars !== 0) items.push({
    client_id: uuid(),
    category_key: "food",
    amount: sign * centsFromDollars(foodDollars),
    note: null,
    occurred_at,
    created_by
  });

  if (funDollars !== 0) items.push({
    client_id: uuid(),
    category_key: "fun",
    amount: sign * centsFromDollars(funDollars),
    note: null,
    occurred_at,
    created_by
  });

  if (gasDollars !== 0) items.push({
    client_id: uuid(),
    category_key: "gas",
    amount: sign * centsFromDollars(gasDollars),
    note: null,
    occurred_at,
    created_by
  });

  if (!items.length) return;

  await upsertLedgerItems(items);
  enqueueOfflineBatch({ items });

  if (navigator.onLine) {
    try {
      await syncNow();
      showSuccess('Saved');
    } catch (e) {
      console.error(e);
      showSuccess('Saved (sync pending)');
    }
  } else {
    showSuccess('Saved (offline)');
  }
}

/* =========================================================
   SYNC ENGINE
   ========================================================= */

async function pushQueueOnce() {
  if (!db) return;

  const tx = db.transaction('tx', 'readwrite');
  const store = tx.objectStore('tx');

  return new Promise((resolve, reject) => {
    const req = store.openCursor();

    req.onsuccess = async (e) => {
      const c = e.target.result;
      if (!c) return resolve();

      const batch = c.value;

      if (!batch || !Array.isArray(batch.items) || batch.items.length === 0) {
        store.delete(c.key);
        c.continue();
        return;
      }

      try {
        await apiPostJson('/api/expenses/batch', batch);
        store.delete(c.key);
        c.continue();
      } catch (err) {
        reject(err);
      }
    };

    req.onerror = () => reject(req.error);
  });
}

async function pullChanges() {
  const since = Number((await getMeta('cursor')) || 0);
  const res = await apiGet(`/api/changes?since=${encodeURIComponent(String(since))}`);

  if (Array.isArray(res.expenses) && res.expenses.length) {
    await upsertLedgerItems(res.expenses);
  }

  if (typeof res.cursor === "number") {
    await setMeta('cursor', res.cursor);
  }

  return res;
}

async function syncNow() {
  if (!navigator.onLine) return;

  isSyncing = true;
  setNetStatus('Syncing…');

  try {
    await apiHealth();
    await pushQueueOnce();
    await pullChanges();
    await pruneLocalData(PRUNE_DAYS);
  } finally {
    isSyncing = false;
    setNetStatus();
  }
}

/* =========================================================
   SETTINGS MODAL (applies NEXT Eastern semi-monthly period)
   ========================================================= */

function openSettings() {
  settingsBackdrop.style.display = 'flex';
  settingsBackdrop.setAttribute('aria-hidden', 'false');

  Promise.all([
    getCurrentPeriodBudgetsCents(),
    getMeta('next_budget_food_cents'),
    getMeta('next_budget_fun_cents'),
    getMeta('next_budget_gas_cents'),
  ]).then(([cur, nFood, nFun, nGas]) => {
    const next = nextPeriodInfoET(new Date());
    settingsSubtitle.textContent =
      `Budget changes apply starting the next period (${next.label}) so they do not change the current period’s remaining amounts.`;

    const foodC = Number(nFood ?? cur.food);
    const funC  = Number(nFun  ?? cur.fun);
    const gasC  = Number(nGas  ?? cur.gas);

    setFood.value = String(dollarsFromCents(foodC));
    setFun.value  = String(dollarsFromCents(funC));
    setGas.value  = String(dollarsFromCents(gasC));
  });
}

function closeSettings() {
  settingsBackdrop.style.display = 'none';
  settingsBackdrop.setAttribute('aria-hidden', 'true');
}

async function saveSettings() {
  const f = clampNonNegative(parseDollarsFromText(setFood.value));
  const u = clampNonNegative(parseDollarsFromText(setFun.value));
  const g = clampNonNegative(parseDollarsFromText(setGas.value));

  if (!Number.isFinite(f) || !Number.isFinite(u) || !Number.isFinite(g)) {
    showSuccess('Enter valid non-negative amounts');
    return;
  }

  await setMeta('next_budget_food_cents', centsFromDollars(f));
  await setMeta('next_budget_fun_cents',  centsFromDollars(u));
  await setMeta('next_budget_gas_cents',  centsFromDollars(g));

  closeSettings();
  showSuccess('Saved (next period)');
}

/* =========================================================
   EVENT WIRING
   ========================================================= */

settingsBtn.addEventListener('click', openSettings);
settingsCancel.addEventListener('click', closeSettings);
settingsBackdrop.addEventListener('click', (e) => { if (e.target === settingsBackdrop) closeSettings(); });
settingsSave.addEventListener('click', () => saveSettings().catch(console.error));

modeExpenseBtn.addEventListener('click', () => setMode("expense"));
modeRefundBtn.addEventListener('click', () => setMode("refund"));

function normalizeFieldTextInput(el) {
  // prevent minus sign entry; refunds handled by toggle
  el.value = String(el.value).replace(/-/g, '');
}
foodInput.addEventListener('input', () => { normalizeFieldTextInput(foodInput); updateButtonState(); });
funInput.addEventListener('input',  () => { normalizeFieldTextInput(funInput);  updateButtonState(); });
gasInput.addEventListener('input',  () => { normalizeFieldTextInput(gasInput);  updateButtonState(); });

submitBtn.addEventListener('click', async (e) => {
  e.preventDefault();

  const food = parseDollarsFromText(foodInput.value) || 0;
  const fun  = parseDollarsFromText(funInput.value) || 0;
  const gas  = parseDollarsFromText(gasInput.value) || 0;

  foodInput.value = '';
  funInput.value = '';
  gasInput.value = '';
  updateButtonState();

  if ((!Number.isFinite(food) && food !== 0) || (!Number.isFinite(fun) && fun !== 0) || (!Number.isFinite(gas) && gas !== 0)) {
    showSuccess('Invalid number');
    return;
  }

  if (food === 0 && fun === 0 && gas === 0) return;

  try {
    await submitExpenses(food, fun, gas);
    await loadSummary();
  } catch (err) {
    console.error(err);
  }
});

window.addEventListener('online', () => {
  setNetStatus();
  syncNow().then(loadSummary).catch(console.error);
});

window.addEventListener('offline', () => {
  isSyncing = false;
  setNetStatus();
});

setInterval(() => {
  if (navigator.onLine) syncNow().then(loadSummary).catch(() => {});
}, 25000);

setMode("expense");
setNetStatus();
updateButtonState();

(async function boot() {
  try { await syncNow(); }
  catch (e) { console.error(e); }
  finally { await loadSummary(); }
})();
</script>
</body>
</html>
