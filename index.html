<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="theme-color" content="#0b1320" />
<title>Purrfect Budget</title>

<style>
:root{
  --bg0:#070b12; --bg1:#0b1320;
  --border:rgba(255,255,255,.10);
  --text:#e9eef7; --muted:rgba(233,238,247,.75);
  --danger:#ffb4b4; --ok:#b6ffcf;
  --radius:16px;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  color:var(--text);
  background:
    radial-gradient(900px 480px at 10% 0%, rgba(45,108,223,.22), transparent 60%),
    radial-gradient(720px 360px at 90% 10%, rgba(182,255,207,.10), transparent 60%),
    linear-gradient(180deg,var(--bg0),var(--bg1));
}
.wrap{max-width:1100px;margin:0 auto;padding:18px}
h1{font-size:18px;margin:0 0 10px}
.card{
  background:linear-gradient(180deg,rgba(255,255,255,.07),rgba(255,255,255,.045));
  border:1px solid var(--border);
  border-radius:var(--radius);
  padding:16px;
}
.subcard{margin-top:14px}
.hidden{display:none!important}
.row{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
label{font-size:13px;color:var(--muted);margin-top:10px;display:block}
input,select{
  width:100%;padding:10px;border-radius:12px;
  background:rgba(0,0,0,.35);color:var(--text);
  border:1px solid var(--border)
}
button{
  border:0;border-radius:12px;padding:10px 14px;
  font-weight:600;color:#fff;cursor:pointer;
  background:linear-gradient(180deg,#2d6cdf,#1f57c8)
}
button.secondary{background:rgba(255,255,255,.12)}
button.danger{background:rgba(255,180,180,.18);color:#ffd7d7}
button:disabled{opacity:.55}
.status{font-size:13px;color:var(--muted);margin-top:8px;white-space:pre-wrap}
.status.ok{color:var(--ok)} .status.error{color:var(--danger)}
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:16px}
@media(max-width:900px){.grid2{grid-template-columns:1fr}}
table{width:100%;border-collapse:collapse;margin-top:10px}
th,td{padding:6px;border-bottom:1px solid var(--border)}
th{text-align:left;font-size:13px;color:var(--muted)}
td.right{text-align:right}
th.center, td.center { text-align:center; } /* NEW */
.tableScroll{max-height:360px;overflow:auto}

.fabWrap{
  position:fixed;right:18px;bottom:18px;z-index:50;
  display:flex;flex-direction:column;gap:10px;align-items:flex-end;
}
.fab{}

/* Shared modal overlay */
.modalOverlay{
  position:fixed;inset:0;background:rgba(0,0,0,.6);
  display:flex;align-items:flex-start;justify-content:center;
  padding:18px;z-index:100
}
.modal{
  max-width:880px;width:100%;
  max-height:calc(100vh - 36px);
  overflow:auto;

  /* opaque modal */
  background: var(--bg1);
  border:1px solid var(--border);
  border-radius:16px;
  padding:16px;
  opacity: 1;
}
.modalHeader{display:flex;justify-content:space-between;align-items:center;gap:10px}
.divider{height:1px;background:rgba(255,255,255,.10);margin:12px 0}
.small{font-size:12px;color:var(--muted)}

/* Reorder styles (existing) */
.reorderItem{
  display:flex;align-items:center;justify-content:space-between;
  gap:10px;padding:8px;border:1px solid rgba(255,255,255,.10);
  border-radius:12px;margin-top:8px;background:rgba(0,0,0,.18)
}
.reorderBtns{display:flex;gap:8px;flex:0 0 auto}
.reorderBtns button{padding:8px 10px}

/* History list styles (NEW) */
.historyToolbar{
  display:flex;gap:10px;flex-wrap:wrap;align-items:center;
}
.historyToolbar .grow{flex:1 1 240px}
.pill{
  display:inline-flex;gap:8px;align-items:center;
  padding:8px 10px;border-radius:999px;
  border:1px solid var(--border);
  background:rgba(0,0,0,.22);
  font-size:12px;color:var(--muted);
}
.badge{
  display:inline-block;padding:2px 8px;border-radius:999px;
  border:1px solid rgba(255,255,255,.14);
  font-size:12px;color:var(--muted);
}
.badge.expense{color:#ffd7d7;background:rgba(255,180,180,.10)}
.badge.refund{color:#b6ffcf;background:rgba(182,255,207,.08)}
.badge.transfer{color:#cfe0ff;background:rgba(45,108,223,.14)}
.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace}
</style>
</head>

<body>
<div class="wrap">
  <h1>Purrfect Budget</h1>

  <!-- AUTH -->
  <div id="authView" class="card hidden">
    <label>Your name</label>
    <input id="userNameInput" placeholder="e.g. Alex" autocomplete="off" />
    <label>Bearer token</label>
    <input id="tokenInput" type="password" autocomplete="off" />
    <div class="row">
      <button id="saveTokenBtn" type="button">Continue</button>
      <button id="toggleTokenBtn" class="secondary" type="button">Show</button>
    </div>
    <div id="authStatus" class="status"></div>
  </div>

  <!-- SETUP WIZARD -->
  <div id="noCategoriesView" class="hidden">
    <div id="wizStep1" class="card">
      <h1>Step 1 — Budget period</h1>

      <label>Period type</label>
      <select id="wizPeriodType">
        <option value="daily">Daily</option>
        <option value="weekly">Weekly</option>
        <option value="biweekly" selected>Every Two Weeks</option>
        <option value="semi_monthly">Twice a Month</option>
        <option value="monthly">Monthly</option>
        <option value="quarterly">Quarterly</option>
      </select>

      <p class="status" style="margin-top:6px;">
        Budgets reset automatically at the start of each period.
      </p>

      <label>Start date (MM-DD-YYYY)</label>
      <input id="wizStartDate" placeholder="MM-DD-YYYY" inputmode="numeric" />

      <div class="row">
        <button id="wizNext1" type="button">Next</button>
      </div>
      <div id="wizStatus1" class="status"></div>
    </div>

    <div id="wizStep2" class="card hidden">
      <h1>Step 2 — Categories</h1>
      <div id="wizCatList"></div>
      <div class="row">
        <button id="wizAddCat" class="secondary" type="button">Add Category</button>
        <button id="wizNext2" type="button">Next</button>
      </div>
      <div id="wizStatus2" class="status"></div>
    </div>

    <div id="wizStep3" class="card hidden">
      <h1>Step 3 — Confirm</h1>
      <div id="wizReview" class="status"></div>
      <div class="row">
        <button id="wizSubmit" type="button">Initialize Budget</button>
      </div>
      <div id="wizStatus3" class="status"></div>
    </div>
  </div>

  <!-- APP -->
  <div id="appView" class="hidden">
    <div id="dashboardView" class="hidden">

      <div class="card">
        <h1>Budget Summary</h1>
        <div class="status">Period: <strong id="periodLabel">—</strong></div>

        <div class="tableScroll">
          <table>
            <thead>
              <tr>
                <th>Category</th>
                <th class="center">Remaining</th> <!-- CHANGED -->
                <th class="center">Spent</th>     <!-- CHANGED -->
              </tr>
            </thead>
            <tbody id="catTableBody"></tbody>
          </table>
        </div>
      </div>

      <div class="grid2">
        <div class="card subcard">
          <h1>Add Transaction</h1>

          <label>Type</label>
          <select id="txType">
            <option value="expense">Expense</option>
            <option value="refund">Refund</option>
            <option value="transfer">Transfer</option> <!-- NEW -->
          </select>

          <!-- Single-category mode -->
          <div id="txSingleCatWrap">
            <label>Category</label>
            <select id="txCategory"></select>
          </div>

          <!-- Transfer mode -->
          <div id="txTransferWrap" class="hidden">
            <label>Transfer from</label>
            <select id="txFromCategory"></select>

            <label>Transfer to</label>
            <select id="txToCategory"></select>
          </div>

          <label>Amount</label>
          <input id="txAmount" placeholder="$0.00" inputmode="decimal" />

          <label>Note</label>
          <input id="txNote" />

          <div class="row">
            <button id="txSubmitBtn" type="button">Save</button>
          </div>
          <div id="txStatus" class="status"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Floating buttons -->
  <div class="fabWrap">
    <button id="openHistoryBtn" class="fab secondary" type="button">History</button> <!-- NEW -->
    <button id="openSettingsBtn" class="fab" type="button">Settings</button>
  </div>

  <div id="globalStatus" class="status"></div>
</div>

<!-- SETTINGS MODAL -->
<div id="settingsOverlay" class="modalOverlay hidden" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true">
    <div class="modalHeader">
      <h1 style="margin:0;">Settings</h1>
      <button id="settingsCloseBtn" class="secondary" type="button">Close</button>
    </div>

    <div class="divider"></div>

    <div class="card">
      <h1>Budget Categories</h1>
      <div class="row">
        <button id="settingsOpenReorderBtn" class="secondary" type="button">Reorder Budget Categories</button>
      </div>

      <div id="settingsReorderPanel" class="subcard hidden">
        <div class="status" style="margin-top:0;">
          Move categories up/down. This affects how categories are shown in the app on this device.
        </div>
        <div id="settingsReorderList"></div>
        <div class="row">
          <button id="settingsSaveOrderBtn" type="button">Save Order</button>
          <button id="settingsCancelOrderBtn" class="secondary" type="button">Cancel</button>
        </div>
        <div id="settingsReorderStatus" class="status"></div>
      </div>

      <!-- Add Budget Categories -->
      <div class="subcard" style="margin-top:14px;">
        <div class="row">
          <button id="settingsOpenAddCatsBtn" class="secondary" type="button">Add Budget Categories</button>
        </div>

        <div id="settingsAddCatsPanel" class="subcard hidden" style="margin-top:10px;">
          <div class="status" style="margin-top:0;">
            Add one or more categories with their starting budget amounts.
          </div>

          <div id="settingsAddCatsList"></div>

          <div class="row">
            <button id="settingsAddCatsRowBtn" class="secondary" type="button">Add Row</button>
          </div>

          <div class="row">
            <button id="settingsSaveCatsBtn" type="button">Save Categories</button>
            <button id="settingsCancelCatsBtn" class="secondary" type="button">Cancel</button>
          </div>

          <div id="settingsAddCatsStatus" class="status"></div>
        </div>
      </div>
    </div>

    <div class="card subcard">
      <h1>Account</h1>
      <div class="row">
        <button id="settingsLogoutBtn" class="secondary" type="button">Log Out</button>
        <button id="settingsResetBtn" class="danger" type="button">Reset Budget</button>
      </div>
      <div class="small" style="margin-top:8px;">
        Reset clears categories, budgets, and all transaction history from the server.
      </div>
      <div id="settingsAccountStatus" class="status"></div>
    </div>
  </div>
</div>
<!-- HISTORY MODAL (NEW) -->
<div id="historyOverlay" class="modalOverlay hidden" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true">
    <div class="modalHeader">
      <h1 style="margin:0;">History</h1>
      <button id="historyCloseBtn" class="secondary" type="button">Close</button>
    </div>

    <div class="divider"></div>

    <div class="historyToolbar">
      <div class="pill">
        Viewing:
        <strong id="historyWhichPeriodLabel">—</strong>
      </div>

      <div class="grow"></div>

      <button id="historyViewCurrentBtn" class="secondary" type="button">Current Period</button>
      <button id="historyViewPriorBtn" class="secondary" type="button">Prior Period</button>
    </div>

    <div id="historyStatus" class="status"></div>

    <div class="tableScroll" style="margin-top:10px;">
      <table>
        <thead>
          <tr>
            <th>When</th>
            <th>Type</th>
            <th>Category</th>
            <th>By</th>
            <th class="right">Amount</th>
            <th>Note</th>
          </tr>
        </thead>
        <tbody id="historyTableBody"></tbody>
      </table>
    </div>

    <div class="small" style="margin-top:10px;">
      Tip: Transfers are shown as paired rows (Transfer Out / Transfer In).
    </div>
  </div>
</div>

<script>
/* ================= CONFIG ================= */
const API = {
  base: "https://purrfect-budget-api.kardian.workers.dev",
  validate: "/api/auth/validate",
  state: "/api/budget/state",
  init: "/api/budget/init",
  tx: "/api/budget/transactions",
  categories: "/api/budget/categories",
  reset: "/api/budget/reset",
  timeoutMs: 12000
};

/* ================= DOM ================= */
const $ = (id) => document.getElementById(id);

const authView = $("authView");
const userNameInput = $("userNameInput");
const tokenInput = $("tokenInput");
const saveTokenBtn = $("saveTokenBtn");
const toggleTokenBtn = $("toggleTokenBtn");
const authStatus = $("authStatus");

const noCategoriesView = $("noCategoriesView");
const wizStep1 = $("wizStep1");
const wizStep2 = $("wizStep2");
const wizStep3 = $("wizStep3");
const wizPeriodType = $("wizPeriodType");
const wizStartDate = $("wizStartDate");
const wizCatList = $("wizCatList");
const wizReview = $("wizReview");
const wizNext1 = $("wizNext1");
const wizAddCat = $("wizAddCat");
const wizNext2 = $("wizNext2");
const wizSubmit = $("wizSubmit");
const wizStatus1 = $("wizStatus1");
const wizStatus2 = $("wizStatus2");
const wizStatus3 = $("wizStatus3");

const appView = $("appView");
const dashboardView = $("dashboardView");
const periodLabel = $("periodLabel");
const catTableBody = $("catTableBody");

const txType = $("txType");
const txSingleCatWrap = $("txSingleCatWrap");     // NEW
const txTransferWrap = $("txTransferWrap");       // NEW
const txCategory = $("txCategory");
const txFromCategory = $("txFromCategory");       // NEW
const txToCategory = $("txToCategory");           // NEW
const txAmount = $("txAmount");
const txNote = $("txNote");
const txSubmitBtn = $("txSubmitBtn");
const txStatus = $("txStatus");

const globalStatus = $("globalStatus");

const openSettingsBtn = $("openSettingsBtn");
const settingsOverlay = $("settingsOverlay");
const settingsCloseBtn = $("settingsCloseBtn");

const settingsOpenReorderBtn = $("settingsOpenReorderBtn");
const settingsReorderPanel = $("settingsReorderPanel");
const settingsReorderList = $("settingsReorderList");
const settingsSaveOrderBtn = $("settingsSaveOrderBtn");
const settingsCancelOrderBtn = $("settingsCancelOrderBtn");
const settingsReorderStatus = $("settingsReorderStatus");

const settingsOpenAddCatsBtn = $("settingsOpenAddCatsBtn");
const settingsAddCatsPanel = $("settingsAddCatsPanel");
const settingsAddCatsList = $("settingsAddCatsList");
const settingsAddCatsRowBtn = $("settingsAddCatsRowBtn");
const settingsSaveCatsBtn = $("settingsSaveCatsBtn");
const settingsCancelCatsBtn = $("settingsCancelCatsBtn");
const settingsAddCatsStatus = $("settingsAddCatsStatus");

const settingsLogoutBtn = $("settingsLogoutBtn");
const settingsResetBtn = $("settingsResetBtn");
const settingsAccountStatus = $("settingsAccountStatus");

/* NEW: History modal DOM */
const openHistoryBtn = $("openHistoryBtn");
const historyOverlay = $("historyOverlay");
const historyCloseBtn = $("historyCloseBtn");
const historyViewCurrentBtn = $("historyViewCurrentBtn");
const historyViewPriorBtn = $("historyViewPriorBtn");
const historyWhichPeriodLabel = $("historyWhichPeriodLabel");
const historyStatus = $("historyStatus");
const historyTableBody = $("historyTableBody");

/* ================= UI HELPERS ================= */
function show(el){ if (el) el.classList.remove("hidden"); }
function hide(el){ if (el) el.classList.add("hidden"); }

function setStatus(el, msg, kind){
  if (!el) return;
  el.textContent = msg || "";
  el.classList.remove("ok","error");
  if (kind) el.classList.add(kind);
}

function join(path){
  return API.base.replace(/\/+$/,"") + "/" + path.replace(/^\/+/,"");
}

function authHeaders(token){
  return { Authorization:`Bearer ${token}`, "Content-Type":"application/json" };
}

function fetchWithTimeout(url, options = {}){
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), API.timeoutMs);
  return fetch(url, { ...options, signal: controller.signal }).finally(() => clearTimeout(id));
}

async function safeText(resp){
  try { return await resp.text(); } catch { return ""; }
}

/* ================= INDEXEDDB (ROBUST) ================= */
const IDB = { name:"pwa-budget-app", version:4, store:"kv" };
const KEY_TOKEN = "token";
const KEY_NAME  = "name";
const KEY_CAT_ORDER = "catOrder"; // array of category_id numbers in desired UI order

function deleteDb(){
  return new Promise((resolve) => {
    const del = indexedDB.deleteDatabase(IDB.name);
    del.onsuccess = () => resolve(true);
    del.onerror = () => resolve(false);
    del.onblocked = () => resolve(false);
  });
}

function openDbOnce(versionOverride){
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(IDB.name, versionOverride ?? IDB.version);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(IDB.store)) db.createObjectStore(IDB.store);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function openDb(){
  try {
    const db = await openDbOnce();
    if (!db.objectStoreNames.contains(IDB.store)) {
      db.close();
      await deleteDb();
      return await openDbOnce();
    }
    return db;
  } catch (e) {
    const msg = String(e?.message || e || "");
    if (msg.includes("higher version")) {
      await deleteDb();
      return await openDbOnce();
    }
    throw e;
  }
}

async function idbGet(key){
  const db = await openDb();
  try {
    return await new Promise((resolve, reject) => {
      const tx = db.transaction(IDB.store, "readonly");
      const store = tx.objectStore(IDB.store);
      const req = store.get(key);
      req.onsuccess = () => resolve(req.result ?? null);
      req.onerror = () => reject(req.error);
    });
  } finally { db.close(); }
}

async function idbSet(key, value){
  const db = await openDb();
  try {
    return await new Promise((resolve, reject) => {
      const tx = db.transaction(IDB.store, "readwrite");
      const store = tx.objectStore(IDB.store);
      const req = store.put(value, key);
      req.onsuccess = () => resolve(true);
      req.onerror = () => reject(req.error);
    });
  } finally { db.close(); }
}

async function idbDel(key){
  const db = await openDb();
  try {
    return await new Promise((resolve, reject) => {
      const tx = db.transaction(IDB.store, "readwrite");
      const store = tx.objectStore(IDB.store);
      const req = store.delete(key);
      req.onsuccess = () => resolve(true);
      req.onerror = () => reject(req.error);
    });
  } finally { db.close(); }
}
</script>

<script>
/* ================= API ================= */
async function validateToken(token){
  const url = join(API.validate);
  const resp = await fetchWithTimeout(url, { method:"GET", headers: authHeaders(token) });
  if (resp.ok) return true;
  if (resp.status === 401 || resp.status === 403) return false;
  const t = await safeText(resp);
  throw new Error(`Token validate failed (${resp.status}): ${t || resp.statusText}`);
}

async function fetchState(token){
  const url = join(API.state);
  const resp = await fetchWithTimeout(url, { method:"GET", headers: authHeaders(token) });
  if (!resp.ok){
    if (resp.status === 401 || resp.status === 403) return { authFailed:true, state:null };
    const t = await safeText(resp);
    throw new Error(`State failed (${resp.status}): ${t || resp.statusText}`);
  }
  return { authFailed:false, state: await resp.json().catch(()=> ({})) };
}

async function postInit(token, payload){
  const url = join(API.init);
  const resp = await fetchWithTimeout(url, { method:"POST", headers: authHeaders(token), body: JSON.stringify(payload) });
  if (!resp.ok){
    if (resp.status === 401 || resp.status === 403) return { authFailed:true, result:null };
    const t = await safeText(resp);
    throw new Error(`Init failed (${resp.status}): ${t || resp.statusText}`);
  }
  return { authFailed:false, result: await resp.json().catch(()=> ({})) };
}

async function postTransaction(token, payload){
  const url = join(API.tx);
  const resp = await fetchWithTimeout(url, { method:"POST", headers: authHeaders(token), body: JSON.stringify(payload) });
  if (!resp.ok){
    if (resp.status === 401 || resp.status === 403) return { authFailed:true, result:null };
    const t = await safeText(resp);
    throw new Error(`Transaction failed (${resp.status}): ${t || resp.statusText}`);
  }
  return { authFailed:false, result: await resp.json().catch(()=> ({})) };
}

/* NEW: fetch transactions for history
   NOTE: Your current Worker GET /api/budget/transactions returns *current* period.
   The prior-period button will attempt ?period_key=... as a "clean follow-on" contract.
   If you later add this param to the Worker, this UI will start showing prior transactions automatically. */
async function fetchTransactions(token, opts = {}){
  const params = new URLSearchParams();
  if (opts?.sinceMs) params.set("since", String(opts.sinceMs));
  if (opts?.limit) params.set("limit", String(opts.limit));
  if (opts?.period_key) params.set("period_key", String(opts.period_key)); // follow-on support

  const url = join(API.tx) + (params.toString() ? `?${params}` : "");
  const resp = await fetchWithTimeout(url, { method:"GET", headers: authHeaders(token) });
  if (!resp.ok){
    if (resp.status === 401 || resp.status === 403) return { authFailed:true, result:null };
    const t = await safeText(resp);
    throw new Error(`History failed (${resp.status}): ${t || resp.statusText}`);
  }
  return { authFailed:false, result: await resp.json().catch(()=> ({})) };
}

async function postReset(token){
  const url = join(API.reset);
  const resp = await fetchWithTimeout(url, {
    method:"POST",
    headers: authHeaders(token),
    body: JSON.stringify({ confirm:"RESET" })
  });
  if (!resp.ok){
    if (resp.status === 401 || resp.status === 403) return { authFailed:true, result:null };
    const t = await safeText(resp);
    throw new Error(`Reset failed (${resp.status}): ${t || resp.statusText}`);
  }
  return { authFailed:false, result: await resp.json().catch(()=> ({})) };
}

async function postCategories(token, payload){
  const url = join(API.categories);
  const resp = await fetchWithTimeout(url, {
    method:"POST",
    headers: authHeaders(token),
    body: JSON.stringify(payload)
  });
  if (!resp.ok){
    if (resp.status === 401 || resp.status === 403) return { authFailed:true, result:null };
    const t = await safeText(resp);
    throw new Error(`Categories failed (${resp.status}): ${t || resp.statusText}`);
  }
  return { authFailed:false, result: await resp.json().catch(()=> ({})) };
}

/* ================= DATE + MONEY ================= */
const pad2 = (n) => String(n).padStart(2, "0");

function todayYMD(){
  const d = new Date();
  return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
}

function ymdToMdy(ymd){
  const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(String(ymd||""));
  if (!m) return "";
  return `${m[2]}-${m[3]}-${m[1]}`;
}

function mdyToYmd(mdy){
  const s = String(mdy||"").trim();
  const m = /^(\d{2})-(\d{2})-(\d{4})$/.exec(s);
  if (!m) return null;
  const mm = Number(m[1]), dd = Number(m[2]), yyyy = Number(m[3]);
  if (yyyy < 1900 || yyyy > 2100) return null;
  const dt = new Date(yyyy, mm-1, dd);
  if (dt.getFullYear() !== yyyy || dt.getMonth() !== (mm-1) || dt.getDate() !== dd) return null;
  return `${yyyy}-${pad2(mm)}-${pad2(dd)}`;
}

function normalizeMoneyDisplay(s){
  const raw = String(s||"").trim().replace(/[^0-9.]/g,"");
  if (!raw) return "";
  const n = Number(raw);
  if (!Number.isFinite(n)) return "";
  return "$" + n.toFixed(2);
}

function dollarsToCentsFromInput(s){
  const raw = String(s||"").trim().replace(/[^0-9.]/g,"");
  if (!raw) return null;
  const n = Number(raw);
  if (!Number.isFinite(n) || n <= 0) return null;
  return Math.round(n*100);
}

function fmtCents(c){
  const n = Number(c);
  if (!Number.isFinite(n)) return "—";
  return "$" + (n/100).toFixed(2);
}
</script>
<script>
/* ================= CATEGORY ORDERING (UI ONLY) ================= */
function normalizeCategories(state){
  const cats = Array.isArray(state?.categories) ? state.categories : [];
  return cats.map(c => ({
    category_id: Number(c.category_id),
    name: String(c.name || ""),
    spent_cents: Number(c.spent_cents) || 0,
    remaining_cents: Number(c.remaining_cents) || 0
  })).filter(c => Number.isFinite(c.category_id) && c.category_id > 0 && c.name);
}

async function applyUiOrder(cats){
  const saved = await idbGet(KEY_CAT_ORDER);
  if (!Array.isArray(saved) || saved.length === 0) return cats;

  const order = saved.map(Number).filter(n => Number.isFinite(n) && n > 0);
  const byId = new Map(cats.map(c => [c.category_id, c]));

  const out = [];
  const seen = new Set();

  for (const id of order){
    const c = byId.get(id);
    if (c) { out.push(c); seen.add(id); }
  }
  for (const c of cats){
    if (!seen.has(c.category_id)) out.push(c);
  }
  return out;
}

async function ensureOrderDefaults(cats){
  const saved = await idbGet(KEY_CAT_ORDER);

  if (!Array.isArray(saved) || saved.length === 0) {
    await idbSet(KEY_CAT_ORDER, cats.map(c => c.category_id));
    return;
  }

  const order = saved.map(Number).filter(n => Number.isFinite(n) && n > 0);
  const set = new Set(order);
  let changed = false;
  for (const c of cats){
    if (!set.has(c.category_id)) { order.push(c.category_id); set.add(c.category_id); changed = true; }
  }
  if (changed) await idbSet(KEY_CAT_ORDER, order);
}

/* ================= DASHBOARD ================= */
async function renderDashboard(state){
  const p = state?.period;
  if (p?.start_ts && p?.end_ts) {
    periodLabel.textContent = `${String(p.start_ts).slice(0,10)} → ${String(p.end_ts).slice(0,10)}`;
  } else {
    periodLabel.textContent = "—";
  }

  let cats = normalizeCategories(state);
  await ensureOrderDefaults(cats);
  cats = await applyUiOrder(cats);

  catTableBody.innerHTML = "";
  for (const c of cats){
    const tr = document.createElement("tr");

    const tdName = document.createElement("td");
    tdName.textContent = c.name;

    const tdRem = document.createElement("td");
    tdRem.className = "center";
    tdRem.textContent = fmtCents(c.remaining_cents);

    const tdSpent = document.createElement("td");
    tdSpent.className = "center";
    tdSpent.textContent = fmtCents(c.spent_cents);

    tr.appendChild(tdName);
    tr.appendChild(tdRem);
    tr.appendChild(tdSpent);
    catTableBody.appendChild(tr);
  }

  // Populate transaction selects
  txCategory.innerHTML = "";
  txFromCategory.innerHTML = "";
  txToCategory.innerHTML = "";

  for (const c of cats){
    const opt = document.createElement("option");
    opt.value = String(c.category_id);
    opt.textContent = c.name;
    txCategory.appendChild(opt);

    const o1 = opt.cloneNode(true);
    const o2 = opt.cloneNode(true);
    txFromCategory.appendChild(o1);
    txToCategory.appendChild(o2);
  }
}

/* ================= SETTINGS + HISTORY MODALS ================= */
function openSettings(){
  settingsOverlay.classList.remove("hidden");
  settingsOverlay.setAttribute("aria-hidden", "false");
  setStatus(settingsAccountStatus, "");
  setStatus(settingsReorderStatus, "");
  setStatus(settingsAddCatsStatus, "");
  hide(settingsReorderPanel);
  hide(settingsAddCatsPanel);
}

function closeSettings(){
  settingsOverlay.classList.add("hidden");
  settingsOverlay.setAttribute("aria-hidden", "true");
}

function openHistory(){
  historyOverlay.classList.remove("hidden");
  historyOverlay.setAttribute("aria-hidden", "false");
  historyTableBody.innerHTML = "";
  setStatus(historyStatus, "Loading…");
}

function closeHistory(){
  historyOverlay.classList.add("hidden");
  historyOverlay.setAttribute("aria-hidden", "true");
}

/* ================= HISTORY RENDERING ================= */
function renderHistoryRows(items){
  historyTableBody.innerHTML = "";
  if (!Array.isArray(items) || items.length === 0){
    const tr = document.createElement("tr");
    const td = document.createElement("td");
    td.colSpan = 6;
    td.className = "center";
    td.textContent = "No transactions.";
    tr.appendChild(td);
    historyTableBody.appendChild(tr);
    return;
  }

  for (const it of items){
    const tr = document.createElement("tr");

    const when = document.createElement("td");
    when.className = "mono";
    when.textContent = String(it.created_at || "").replace("T"," ").slice(0,19);

    const type = document.createElement("td");
    const badge = document.createElement("span");
    if (it.is_refund){
      badge.className = "badge refund";
      badge.textContent = "Refund";
    } else {
      badge.className = "badge expense";
      badge.textContent = "Expense";
    }
    if (String(it.note||"").toLowerCase().includes("transfer")){
      badge.className = "badge transfer";
      badge.textContent = "Transfer";
    }
    type.appendChild(badge);

    const cat = document.createElement("td");
    cat.textContent = String(it.category_name || it.category_id || "—");

    const by = document.createElement("td");
    by.textContent = String(it.created_by_label || "—");

    const amt = document.createElement("td");
    amt.className = "right";
    const sign = it.is_refund ? "+" : "−";
    amt.textContent = sign + fmtCents(it.amount_cents).replace("$","$");

    const note = document.createElement("td");
    note.textContent = String(it.note || "");

    tr.appendChild(when);
    tr.appendChild(type);
    tr.appendChild(cat);
    tr.appendChild(by);
    tr.appendChild(amt);
    tr.appendChild(note);

    historyTableBody.appendChild(tr);
  }
}

async function loadHistoryCurrent(){
  const token = await idbGet(KEY_TOKEN);
  if (!token) return;

  historyWhichPeriodLabel.textContent = "Current period";
  setStatus(historyStatus, "Loading current period…");

  try {
    const res = await fetchTransactions(token, { limit: 300 });
    if (res.authFailed){
      await idbDel(KEY_TOKEN);
      closeHistory();
      return showAuth("Token invalid/expired. Please re-enter.", true);
    }
    renderHistoryRows(res.result?.items || []);
    setStatus(historyStatus, "", "");
  } catch (e) {
    setStatus(historyStatus, e?.message || String(e), "error");
  }
}

async function loadHistoryPrior(){
  const token = await idbGet(KEY_TOKEN);
  if (!token || !CURRENT_STATE?.prior_period?.period_key){
    return setStatus(historyStatus, "No prior period available.", "error");
  }

  historyWhichPeriodLabel.textContent = "Prior period";
  setStatus(historyStatus, "Loading prior period…");

  try {
    const res = await fetchTransactions(token, {
      period_key: CURRENT_STATE.prior_period.period_key,
      limit: 300
    });
    if (res.authFailed){
      await idbDel(KEY_TOKEN);
      closeHistory();
      return showAuth("Token invalid/expired. Please re-enter.", true);
    }
    renderHistoryRows(res.result?.items || []);
    setStatus(historyStatus, "", "");
  } catch (e) {
    setStatus(historyStatus, e?.message || String(e), "error");
  }
}

/* ================= TRANSFER TOGGLE ================= */
txType.addEventListener("change", () => {
  const isTransfer = txType.value === "transfer";
  txSingleCatWrap.classList.toggle("hidden", isTransfer);
  txTransferWrap.classList.toggle("hidden", !isTransfer);
});
</script>

<script>
/* ================= BOOTSTRAP + EVENTS ================= */
let CURRENT_STATE = null;

async function loadAppStateAndRender(token){
  show(appView);
  hide(dashboardView);
  hide(noCategoriesView);

  const result = await fetchState(token);
  if (result.authFailed){
    await idbDel(KEY_TOKEN);
    return showAuth("Stored token is invalid/expired. Please re-enter.", true);
  }

  const state = result.state || {};
  if (state.initialized === false){
    show(noCategoriesView);
    initWizard();
    CURRENT_STATE = null;
    return;
  }

  CURRENT_STATE = state;

  show(dashboardView);
  await renderDashboard(state);
}

/* ================= EVENTS: HISTORY ================= */
openHistoryBtn.addEventListener("click", async () => {
  openHistory();
  await loadHistoryCurrent();
});

historyCloseBtn.addEventListener("click", closeHistory);
historyViewCurrentBtn.addEventListener("click", loadHistoryCurrent);
historyViewPriorBtn.addEventListener("click", loadHistoryPrior);

historyOverlay.addEventListener("click", (e) => {
  if (e.target === historyOverlay) closeHistory();
});
</script>
<script>
/* ================= WIZARD ================= */
function showWizardStep(n){
  [wizStep1, wizStep2, wizStep3].forEach((el, idx) => el.classList.toggle("hidden", idx !== n));
}

function addWizRow(name = "", budget = ""){
  const wrap = document.createElement("div");
  wrap.className = "row";
  wrap.style.marginTop = "10px";
  wrap.innerHTML = `
    <input class="wizCatName" placeholder="Category" value="${String(name).replaceAll('"','&quot;')}" />
    <input class="wizCatBudget" placeholder="$0.00" value="${String(budget).replaceAll('"','&quot;')}" inputmode="decimal" />
    <button type="button" class="secondary wizRemoveBtn">Remove</button>
  `;
  const b = wrap.querySelector(".wizCatBudget");
  b.addEventListener("blur", () => { b.value = normalizeMoneyDisplay(b.value); });
  wrap.querySelector(".wizRemoveBtn").addEventListener("click", () => wrap.remove());
  wizCatList.appendChild(wrap);
}

function initWizard(){
  wizCatList.innerHTML = "";
  wizStartDate.value = ymdToMdy(todayYMD());
  addWizRow("Groceries", "300.00");
  addWizRow("Gas", "120.00");
  setStatus(wizStatus1, "");
  setStatus(wizStatus2, "");
  setStatus(wizStatus3, "");
  wizReview.textContent = "";
  showWizardStep(0);
}

function readWizardCategories(){
  const rows = Array.from(wizCatList.querySelectorAll(".row"));
  const cats = [];
  for (const r of rows){
    const name = (r.querySelector(".wizCatName")?.value || "").trim();
    const money = (r.querySelector(".wizCatBudget")?.value || "").trim();
    const dollars = money.replace(/[^0-9.]/g,"");
    if (!name) continue;
    cats.push({ name, sort_order: cats.length + 1, budget_dollars: dollars });
  }
  return cats;
}

function validateWizardStep1(){
  const pt = String(wizPeriodType.value || "").trim();
  const allowed = new Set(["daily","weekly","biweekly","semi_monthly","monthly","quarterly"]);
  if (!allowed.has(pt)) return "Invalid period type.";
  const ymd = mdyToYmd(wizStartDate.value);
  if (!ymd) return "Start date must be MM-DD-YYYY.";
  return null;
}

function validateWizardStep2(){
  const cats = readWizardCategories();
  if (cats.length < 1 || cats.length > 10) return "Please provide 1 to 10 categories.";
  const seen = new Set();
  for (const c of cats){
    if (!c.name) return "Category name cannot be blank.";
    if (!c.budget_dollars) return `Please enter a budget for: ${c.name}`;
    const k = c.name.toLowerCase();
    if (seen.has(k)) return `Duplicate category name: ${c.name}`;
    seen.add(k);
  }
  return null;
}

function renderWizardReview(){
  const pt = String(wizPeriodType.value || "").trim();
  const cats = readWizardCategories();
  let total = 0;

  const lines = [];
  lines.push(`Period type: ${pt}`);
  lines.push(`Start date: ${wizStartDate.value}`);
  lines.push(`Categories (${cats.length}):`);
  for (const c of cats){
    const n = Number(c.budget_dollars);
    if (Number.isFinite(n)) total += n;
    lines.push(`• ${c.name}: $${Number(c.budget_dollars || 0).toFixed(2)}`);
  }
  lines.push(`Total starting budget: $${total.toFixed(2)}`);
  wizReview.textContent = lines.join("\n");
}

async function submitInit(){
  const err1 = validateWizardStep1();
  if (err1){ showWizardStep(0); return setStatus(wizStatus1, err1, "error"); }
  const err2 = validateWizardStep2();
  if (err2){ showWizardStep(1); return setStatus(wizStatus2, err2, "error"); }

  const token = await idbGet(KEY_TOKEN);
  if (!token) return showAuth("Missing token. Please re-enter.", true);

  const payload = {
    period_type: String(wizPeriodType.value || "").trim(),
    period_anchor_date: mdyToYmd(wizStartDate.value),
    categories: readWizardCategories()
  };

  setStatus(wizStatus3, "Initializing…");
  try {
    const res = await postInit(token, payload);
    if (res.authFailed){
      await idbDel(KEY_TOKEN);
      return showAuth("Token invalid/expired. Please re-enter.", true);
    }
    setStatus(wizStatus3, "Initialized. Loading…", "ok");
    await bootstrap();
  } catch (e) {
    setStatus(wizStatus3, e?.message || String(e), "error");
  }
}

/* ================= AUTH/UI FLOW ================= */
function showAuth(message = "", isError = false){
  show(authView);
  hide(appView);
  hide(noCategoriesView);
  setStatus(authStatus, message, isError ? "error" : "");
  setStatus(globalStatus, "");
  userNameInput?.focus();
}

function showApp(){
  hide(authView);
  show(appView);
}

/* ================= ADD CATEGORIES PANEL ================= */
function addSettingsCatRow(name = "", budget = ""){
  const wrap = document.createElement("div");
  wrap.className = "row";
  wrap.style.marginTop = "10px";
  wrap.innerHTML = `
    <input class="setCatName" placeholder="Category" value="${String(name).replaceAll('"','&quot;')}" />
    <input class="setCatBudget" placeholder="$0.00" value="${String(budget).replaceAll('"','&quot;')}" inputmode="decimal" />
    <button type="button" class="secondary setRemoveBtn">Remove</button>
  `;
  const b = wrap.querySelector(".setCatBudget");
  b.addEventListener("blur", () => { b.value = normalizeMoneyDisplay(b.value); });
  wrap.querySelector(".setRemoveBtn").addEventListener("click", () => wrap.remove());
  settingsAddCatsList.appendChild(wrap);
}

function openAddCatsPanel(){
  settingsAddCatsList.innerHTML = "";
  addSettingsCatRow("", "");
  setStatus(settingsAddCatsStatus, "");
  show(settingsAddCatsPanel);
  hide(settingsReorderPanel);

  setTimeout(() => {
    try { settingsAddCatsPanel.scrollIntoView({ block:"start", behavior:"smooth" }); } catch {}
  }, 0);
}

function readSettingsAddCats(){
  const rows = Array.from(settingsAddCatsList.querySelectorAll(".row"));
  const out = [];
  for (const r of rows){
    const name = (r.querySelector(".setCatName")?.value || "").trim();
    const budgetStr = (r.querySelector(".setCatBudget")?.value || "").trim();
    if (!name && !budgetStr) continue;

    const cents = dollarsToCentsFromInput(budgetStr);
    out.push({ name, cents });
  }
  return out;
}

async function saveAddedCategories(){
  const token = await idbGet(KEY_TOKEN);
  if (!token) return showAuth("Missing token. Please re-enter.", true);
  if (!CURRENT_STATE) return setStatus(settingsAddCatsStatus, "No budget loaded yet.", "error");

  const rows = readSettingsAddCats();
  if (rows.length < 1) return setStatus(settingsAddCatsStatus, "Add at least one category.", "error");

  const existing = normalizeCategories(CURRENT_STATE);
  const existingNames = new Set(existing.map(c => c.name.toLowerCase()));

  const seen = new Set();
  const add = [];

  for (let i = 0; i < rows.length; i++){
    const r = rows[i];
    const name = String(r.name || "").trim();
    if (!name) return setStatus(settingsAddCatsStatus, `Row ${i+1}: Category name is required.`, "error");
    if (name.length > 64) return setStatus(settingsAddCatsStatus, `Row ${i+1}: Category name too long.`, "error");

    const key = name.toLowerCase();
    if (existingNames.has(key)) return setStatus(settingsAddCatsStatus, `Category already exists: ${name}`, "error");
    if (seen.has(key)) return setStatus(settingsAddCatsStatus, `Duplicate in this list: ${name}`, "error");
    seen.add(key);

    if (!Number.isInteger(r.cents) || r.cents <= 0) {
      return setStatus(settingsAddCatsStatus, `Row ${i+1}: Enter a budget amount greater than $0.00.`, "error");
    }

    add.push({ name, budget_cents: r.cents });
  }

  const afterCount = existing.length + add.length;
  if (afterCount > 10) {
    return setStatus(settingsAddCatsStatus, `You can have up to 10 active categories. You would have ${afterCount}.`, "error");
  }

  setStatus(settingsAddCatsStatus, "Saving…");

  try {
    const res = await postCategories(token, { add, remove: [] });
    if (res.authFailed){
      await idbDel(KEY_TOKEN);
      closeSettings();
      return showAuth("Token invalid/expired. Please re-enter.", true);
    }

    CURRENT_STATE = res.result || {};
    await renderDashboard(CURRENT_STATE);

    setStatus(settingsAddCatsStatus, "Saved.", "ok");

    settingsAddCatsList.innerHTML = "";
    addSettingsCatRow("", "");

  } catch (e) {
    setStatus(settingsAddCatsStatus, e?.message || String(e), "error");
  }
}

/* ================= REORDER PANEL ================= */
async function openReorderPanel(){
  if (!CURRENT_STATE) return setStatus(settingsReorderStatus, "No budget loaded yet.", "error");

  let cats = normalizeCategories(CURRENT_STATE);
  await ensureOrderDefaults(cats);
  cats = await applyUiOrder(cats);

  settingsReorderList.innerHTML = "";
  for (let i = 0; i < cats.length; i++){
    const c = cats[i];
    const item = document.createElement("div");
    item.className = "reorderItem";
    item.dataset.id = String(c.category_id);

    const left = document.createElement("div");
    left.textContent = c.name;

    const btns = document.createElement("div");
    btns.className = "reorderBtns";

    const up = document.createElement("button");
    up.type = "button";
    up.className = "secondary";
    up.textContent = "Up";
    up.disabled = i === 0;
    up.addEventListener("click", () => {
      const prev = item.previousElementSibling;
      if (prev) settingsReorderList.insertBefore(item, prev);
      refreshReorderButtons();
    });

    const down = document.createElement("button");
    down.type = "button";
    down.className = "secondary";
    down.textContent = "Down";
    down.disabled = i === cats.length - 1;
    down.addEventListener("click", () => {
      const next = item.nextElementSibling;
      if (next) settingsReorderList.insertBefore(next, item);
      refreshReorderButtons();
    });

    btns.appendChild(up);
    btns.appendChild(down);

    item.appendChild(left);
    item.appendChild(btns);
    settingsReorderList.appendChild(item);
  }

  function refreshReorderButtons(){
    const items = Array.from(settingsReorderList.children);
    for (let idx = 0; idx < items.length; idx++){
      const it = items[idx];
      const [upBtn, downBtn] = it.querySelectorAll("button");
      if (upBtn) upBtn.disabled = idx === 0;
      if (downBtn) downBtn.disabled = idx === items.length - 1;
    }
  }

  refreshReorderButtons();
  show(settingsReorderPanel);
  hide(settingsAddCatsPanel);
  setStatus(settingsReorderStatus, "");
}

async function saveReorder(){
  const ids = Array.from(settingsReorderList.children)
    .map(el => Number(el.dataset.id))
    .filter(n => Number.isFinite(n) && n > 0);

  if (ids.length < 1) return setStatus(settingsReorderStatus, "No categories to save.", "error");

  await idbSet(KEY_CAT_ORDER, ids);
  setStatus(settingsReorderStatus, "Saved.", "ok");

  await renderDashboard(CURRENT_STATE);
}

/* ================= TRANSACTIONS (Expense/Refund/Transfer) ================= */
txAmount.addEventListener("blur", () => { txAmount.value = normalizeMoneyDisplay(txAmount.value); });

txSubmitBtn.addEventListener("click", async () => {
  const token = await idbGet(KEY_TOKEN);
  const name = await idbGet(KEY_NAME);

  if (!token) return showAuth("Missing token. Please re-enter.", true);
  if (!name) return showAuth("Missing name. Please re-enter.", true);

  const cents = dollarsToCentsFromInput(txAmount.value);
  if (cents === null) return setStatus(txStatus, "Enter a valid amount greater than $0.00.", "error");

  const noteRaw = String(txNote.value || "").trim().slice(0, 240);
  const note = noteRaw || undefined;

  let items = [];

  if (txType.value === "transfer") {
    const fromId = Number(txFromCategory.value);
    const toId = Number(txToCategory.value);

    if (!Number.isFinite(fromId) || fromId <= 0) return setStatus(txStatus, "Choose a 'from' category.", "error");
    if (!Number.isFinite(toId) || toId <= 0) return setStatus(txStatus, "Choose a 'to' category.", "error");
    if (fromId === toId) return setStatus(txStatus, "Transfer categories must be different.", "error");

    // Clean follow-on: prevent transfer exceeding remaining (client-side hint)
    // If we can find the "from" category remaining in CURRENT_STATE, enforce it.
    const cats = normalizeCategories(CURRENT_STATE);
    const from = cats.find(c => c.category_id === fromId);
    if (from && Number.isFinite(from.remaining_cents) && cents > from.remaining_cents) {
      return setStatus(txStatus, `Transfer exceeds remaining in '${from.name}'.`, "error");
    }

    items = [
      {
        category_id: fromId,
        amount_cents: cents,
        is_refund: false,
        note: note ? `Transfer out — ${note}` : "Transfer out"
      },
      {
        category_id: toId,
        amount_cents: cents,
        is_refund: true,
        note: note ? `Transfer in — ${note}` : "Transfer in"
      }
    ];
  } else {
    const categoryId = Number(txCategory.value);
    if (!Number.isFinite(categoryId) || categoryId <= 0) return setStatus(txStatus, "Please choose a category.", "error");

    items = [{
      category_id: categoryId,
      amount_cents: cents,
      is_refund: txType.value === "refund",
      note
    }];
  }

  const body = {
    created_by_label: name,
    items
  };

  setStatus(txStatus, "Saving…");
  try {
    const res = await postTransaction(token, body);
    if (res.authFailed){
      await idbDel(KEY_TOKEN);
      return showAuth("Token invalid/expired. Please re-enter.", true);
    }
    CURRENT_STATE = res.result || {};
    await renderDashboard(CURRENT_STATE);
    setStatus(txStatus, "Saved.", "ok");
    txAmount.value = "";
    txNote.value = "";
  } catch (e) {
    setStatus(txStatus, e?.message || String(e), "error");
  }
});

/* ================= BOOTSTRAP ================= */
async function bootstrap(){
  setStatus(globalStatus, "Starting…");

  const token = await idbGet(KEY_TOKEN);
  const name = await idbGet(KEY_NAME);

  if (!token){
    userNameInput.value = name || "";
    setStatus(globalStatus, "");
    return showAuth("No token saved. Enter your name and bearer token to continue.");
  }

  try {
    setStatus(globalStatus, "Validating token…");
    const ok = await validateToken(token);
    if (!ok){
      await idbDel(KEY_TOKEN);
      setStatus(globalStatus, "");
      return showAuth("Saved token is invalid or expired. Please enter a new token.", true);
    }
    await loadAppStateAndRender(token);
    setStatus(globalStatus, "");
  } catch (e) {
    setStatus(globalStatus, "");
    showAuth(`Startup error: ${e?.message || String(e)}`, true);
  }
}

/* ================= EVENTS: AUTH ================= */
saveTokenBtn.addEventListener("click", async () => {
  const token = (tokenInput.value || "").trim();
  const name = (userNameInput.value || "").trim();
  if (!name) return setStatus(authStatus, "Please enter your name.", "error");
  if (!token) return setStatus(authStatus, "Please enter a token.", "error");

  setStatus(authStatus, "Validating token…");
  try {
    const ok = await validateToken(token);
    if (!ok) return setStatus(authStatus, "Token is invalid or expired.", "error");

    await idbSet(KEY_NAME, name);
    await idbSet(KEY_TOKEN, token);

    setStatus(authStatus, "Saved. Loading…", "ok");
    await loadAppStateAndRender(token);
  } catch (e) {
    setStatus(authStatus, `Unable to validate token: ${e?.message || String(e)}`, "error");
  }
});

toggleTokenBtn.addEventListener("click", () => {
  const isPw = tokenInput.type === "password";
  tokenInput.type = isPw ? "text" : "password";
  toggleTokenBtn.textContent = isPw ? "Hide" : "Show";
  tokenInput.focus();
});

/* ================= EVENTS: WIZARD ================= */
wizNext1.addEventListener("click", () => {
  const err = validateWizardStep1();
  if (err) return setStatus(wizStatus1, err, "error");
  setStatus(wizStatus1, "");
  showWizardStep(1);
});

wizAddCat.addEventListener("click", () => addWizRow());

wizNext2.addEventListener("click", () => {
  const err = validateWizardStep2();
  if (err) return setStatus(wizStatus2, err, "error");
  setStatus(wizStatus2, "");
  renderWizardReview();
  showWizardStep(2);
});

wizSubmit.addEventListener("click", submitInit);

/* ================= EVENTS: SETTINGS ================= */
openSettingsBtn.addEventListener("click", openSettings);
settingsCloseBtn.addEventListener("click", closeSettings);

settingsOverlay.addEventListener("click", (e) => {
  if (e.target === settingsOverlay) closeSettings();
});

/* Reorder */
settingsOpenReorderBtn.addEventListener("click", async () => {
  await openReorderPanel();
});

settingsCancelOrderBtn.addEventListener("click", () => {
  hide(settingsReorderPanel);
  setStatus(settingsReorderStatus, "");
});

settingsSaveOrderBtn.addEventListener("click", async () => {
  await saveReorder();
});

/* Add categories */
settingsOpenAddCatsBtn.addEventListener("click", openAddCatsPanel);
settingsAddCatsRowBtn.addEventListener("click", () => addSettingsCatRow("", ""));
settingsCancelCatsBtn.addEventListener("click", () => {
  hide(settingsAddCatsPanel);
  setStatus(settingsAddCatsStatus, "");
});
settingsSaveCatsBtn.addEventListener("click", saveAddedCategories);

/* Account */
settingsLogoutBtn.addEventListener("click", async () => {
  await idbDel(KEY_TOKEN);
  await idbDel(KEY_NAME);
  await idbDel(KEY_CAT_ORDER);
  closeSettings();
  showAuth("Logged out. Enter your name and bearer token to continue.");
});

settingsResetBtn.addEventListener("click", async () => {
  const token = await idbGet(KEY_TOKEN);
  if (!token) return showAuth("Missing token. Please re-enter.", true);

  const ok = window.confirm("This will DELETE all categories, budgets, and transactions from the server. Continue?");
  if (!ok) return;

  setStatus(settingsAccountStatus, "Resetting…");
  try {
    const res = await postReset(token);
    if (res.authFailed){
      await idbDel(KEY_TOKEN);
      closeSettings();
      return showAuth("Token invalid/expired. Please re-enter.", true);
    }

    await idbDel(KEY_CAT_ORDER);

    setStatus(settingsAccountStatus, "Reset complete.", "ok");
    closeSettings();

    await loadAppStateAndRender(token);
  } catch (e) {
    setStatus(settingsAccountStatus, e?.message || String(e), "error");
  }
});

/* Safety: surface unhandled rejections */
window.addEventListener("unhandledrejection", (ev) => {
  const msg = ev?.reason?.message || String(ev?.reason || "Unknown error");
  setStatus(globalStatus, `Error: ${msg}`, "error");
});

/* ================= START ================= */
bootstrap();
</script>
</body>
</html>
