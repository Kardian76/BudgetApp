<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Budget Tracker</title>

<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

<!-- PWA -->
<meta name="theme-color" content="#2563eb">
<link rel="manifest" href="./manifest.webmanifest?v=2026-01-13-1">

<!-- iOS + legacy Android -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="Budget">
<meta name="apple-mobile-web-app-status-bar-style" content="default">

<!-- iOS home screen icons -->
<link rel="apple-touch-icon" sizes="180x180" href="./Nova_192.png">
<link rel="apple-touch-icon" sizes="167x167" href="./Nova_192.png">
<link rel="apple-touch-icon" sizes="152x152" href="./Nova_192.png">
<link rel="apple-touch-icon" sizes="120x120" href="./Nova_192.png">

<!-- Optional: suppress favicon.ico 404 -->
<link rel="icon" href="data:,">

<style>
:root {
  --bg-color: #f4f6f9;
  --card-bg: #ffffff;
  --primary: #2563eb;
  --primary-hover: #1d4ed8;
  --text-main: #111827;
  --text-muted: #6b7280;
  --border-color: #e5e7eb;
  --success: #16a34a;
  --warning: #b45309;
  --danger: #b91c1c;

  --safe-top: env(safe-area-inset-top, 0px);
  --safe-right: env(safe-area-inset-right, 0px);
  --safe-bottom: env(safe-area-inset-bottom, 0px);
  --safe-left: env(safe-area-inset-left, 0px);

  --tap-min: 54px;
}

* { box-sizing: border-box; }

html {
  font-size: 22px;
  -webkit-text-size-adjust: 100%;
  text-size-adjust: 100%;
}

body {
  margin: 0;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  background-color: var(--bg-color);
  color: var(--text-main);
}

.container {
  width: 100%;
  padding: calc(1.5rem + var(--safe-top))
           calc(1.5rem + var(--safe-right))
           calc(1.75rem + var(--safe-bottom))
           calc(1.5rem + var(--safe-left));
}

h1 {
  text-align: center;
  margin: 0 0 0.5rem 0;
  font-size: 2.2rem;
  font-weight: 800;
  letter-spacing: -0.015em;
}

.subtitle {
  text-align: center;
  color: var(--text-muted);
  font-size: 1.05rem;
  margin: 0 0 2rem 0;
  line-height: 1.35;
}

.card {
  background: var(--card-bg);
  border-radius: 1.1rem;
  padding: 1.75rem;
  margin-bottom: 1.5rem;
  box-shadow: 0 12px 24px rgba(0,0,0,0.06);
  border: 1px solid rgba(17,24,39,0.05);
}

.summary-row {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin-bottom: 1rem;
  font-size: 1.2rem;
}

.summary-row:last-child { margin-bottom: 0; }
.summary-row span { font-weight: 900; }

h2 {
  text-align: center;
  font-size: 1.35rem;
  margin: 0 0 1.25rem 0;
  font-weight: 900;
  letter-spacing: -0.01em;
}

.form-group-vertical {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  margin-bottom: 1.25rem;
}

input {
  width: 100%;
  min-height: var(--tap-min);
  padding: 0.95rem 1rem;
  font-size: 1.15rem;
  border-radius: 0.85rem;
  border: 1px solid var(--border-color);
  text-align: center;
  background: #fff;
}

input:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 6px rgba(37, 99, 235, 0.18);
}

button {
  width: 100%;
  min-height: var(--tap-min);
  padding: 1rem 1rem;
  font-size: 1.2rem;
  font-weight: 900;
  border-radius: 0.9rem;
  border: none;
  background-color: var(--primary);
  color: #ffffff;
  cursor: pointer;
}

button:hover:not(:disabled) { background-color: var(--primary-hover); }

button:disabled {
  background-color: #9ca3af;
  cursor: not-allowed;
}

.success-message {
  text-align: center;
  font-size: 1rem;
  color: var(--success);
  margin-top: 1rem;
  display: none;
}

.help-text {
  text-align: center;
  margin-top: 0.85rem;
  font-size: 1rem;
  color: var(--text-muted);
  line-height: 1.35;
}

.status-row {
  display: flex;
  justify-content: center;
  margin-top: 1.0rem;
}

.pill {
  display: inline-flex;
  align-items: center;
  padding: 0.4rem 0.9rem;
  border-radius: 999px;
  border: 1px solid var(--border-color);
  font-size: 0.95rem;
  background: #fff;
}

.pill.online  { color: var(--success); }
.pill.offline { color: var(--warning); }
.pill.syncing { color: var(--primary); }
.pill.bad     { color: var(--danger); }

.pending-list {
  margin: 1rem 0 0 0;
  padding-left: 1.25rem;
  font-size: 1.05rem;
}

.pending-list li { margin: 0.5rem 0; }

.pending-empty {
  margin-top: 0.75rem;
  text-align: center;
  color: var(--text-muted);
  font-size: 1rem;
}

.last-grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: 1rem;
}

.last-box {
  border: 1px solid var(--border-color);
  border-radius: 0.85rem;
  padding: 1rem;
  background: #fff;
}

.last-title {
  font-weight: 900;
  margin-bottom: 0.75rem;
  font-size: 1.1rem;
  text-align: center;
}

.last-row {
  display: flex;
  justify-content: space-between;
  font-size: 1.05rem;
  margin: 0.35rem 0;
}

.last-row span { font-weight: 800; }

.center {
  text-align: center;
  margin-top: 1.5rem;
}

img {
  max-width: 130px;
  height: auto;
  opacity: 0.92;
}
</style>
</head>

<body>
<div class="container">
  <h1>Budget Tracker</h1>
  <div class="subtitle">Works offline. Offline entries sync when online.</div>

  <div class="card">
    <div class="summary-row">
      <div>Food Remaining</div>
      <span id="foodRemaining">$0.00</span>
    </div>
    <div class="summary-row">
      <div>Fun Remaining</div>
      <span id="funRemaining">$0.00</span>
    </div>
    <div class="summary-row">
      <div>Gas Remaining</div>
      <span id="gasRemaining">$0.00</span>
    </div>

    <div class="status-row">
      <span class="pill" id="netStatusPill">Checking…</span>
    </div>
    <div class="status-row">
      <span class="pill" id="pwaPill">PWA: checking…</span>
    </div>
    <div class="status-row">
      <span class="pill" id="apiPill">API: checking…</span>
    </div>

    <!-- DEBUG WIDGET -->
    <div class="status-row" style="margin-top: 0.75rem;">
      <details class="pill" id="debugBox" style="width: 100%; justify-content: center; padding: 0.65rem 0.9rem;">
        <summary style="cursor: pointer; font-weight: 900;">Debug</summary>
        <div style="margin-top: 0.75rem; width: 100%; font-size: 0.95rem; color: var(--text-main);">
          <div style="display:flex; justify-content:space-between; gap:1rem; margin:0.35rem 0;">
            <div>API Base</div><span id="dbgApiBase" style="font-weight:800;"></span>
          </div>
          <div style="display:flex; justify-content:space-between; gap:1rem; margin:0.35rem 0;">
            <div>Online</div><span id="dbgOnline" style="font-weight:800;"></span>
          </div>
          <div style="display:flex; justify-content:space-between; gap:1rem; margin:0.35rem 0;">
            <div>Cursor</div><span id="dbgCursor" style="font-weight:800;"></span>
          </div>
          <div style="display:flex; justify-content:space-between; gap:1rem; margin:0.35rem 0;">
            <div>Outbox</div><span id="dbgOutbox" style="font-weight:800;"></span>
          </div>
          <div style="display:flex; justify-content:space-between; gap:1rem; margin:0.35rem 0;">
            <div>Ledger</div><span id="dbgLedger" style="font-weight:800;"></span>
          </div>
          <div style="display:flex; justify-content:space-between; gap:1rem; margin:0.35rem 0;">
            <div>Last Sync</div><span id="dbgLastSync" style="font-weight:800;"></span>
          </div>
          <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid var(--border-color);">
            <div style="font-weight:900; margin-bottom: 0.35rem;">Last API Error</div>
            <div id="dbgLastErr" style="color: var(--danger); font-weight:800; word-break: break-word;">(none)</div>
          </div>
        </div>
      </details>
    </div>
    <!-- /DEBUG WIDGET -->

  </div>

  <div class="card">
    <h2>Enter Expenses / Refunds</h2>

    <div class="form-group-vertical">
      <input type="number" step="0.01" id="foodInput" placeholder="Food" inputmode="decimal">
      <input type="number" step="0.01" id="funInput" placeholder="Fun" inputmode="decimal">
      <input type="number" step="0.01" id="gasInput" placeholder="Gas" inputmode="decimal">
    </div>

    <button id="submitBtn" disabled>Submit</button>
    <div id="successMsg" class="success-message">Saved</div>

    <div class="help-text">
      Tip: enter negative values for refunds or to add money back.
    </div>
  </div>

  <div class="card">
    <h2>Last Budget Period</h2>
    <div class="last-grid">
      <div class="last-box">
        <div class="last-title">Food</div>
        <div class="last-row">
          <div>Spent</div><span id="lastFoodSpent">$0.00</span>
        </div>
        <div class="last-row">
          <div>Leftover</div><span id="lastFoodLeftover">$0.00</span>
        </div>
      </div>

      <div class="last-box">
        <div class="last-title">Fun</div>
        <div class="last-row">
          <div>Spent</div><span id="lastFunSpent">$0.00</span>
        </div>
        <div class="last-row">
          <div>Leftover</div><span id="lastFunLeftover">$0.00</span>
        </div>
      </div>

      <div class="last-box">
        <div class="last-title">Gas</div>
        <div class="last-row">
          <div>Spent</div><span id="lastGasSpent">$0.00</span>
        </div>
        <div class="last-row">
          <div>Leftover</div><span id="lastGasLeftover">$0.00</span>
        </div>
      </div>
    </div>
  </div>

  <div class="card">
    <h2>Pending Offline Transactions</h2>
    <ul id="pendingList" class="pending-list"></ul>
    <div id="pendingEmpty" class="pending-empty">None</div>
  </div>

  <div class="center">
    <img src="./Nova_192.png" alt="Budget App Icon">
  </div>
</div>

<script>
/* =========================================================
   CONFIG (Worker + shared token)
   ========================================================= */

const API_BASE = "https://budgetapp-api.kardian.workers.dev";
const AUTH_TOKEN = "K7QvN2P9x0MZyJHcF4rW8E5U1R_AkDqB3aSXTGm6nVfLw-heCpd";

// Cache-busting version for SW registration
const SW_VERSION = "2026-01-13-1";

// Defaults (dollars)
const DEFAULT_BUDGETS = {
  food: 500,
  fun: 300,
  gas: 200,
};

/* =========================================================
   ELEMENTS / STATE
   ========================================================= */

const netStatusPill = document.getElementById('netStatusPill');
const pwaPill = document.getElementById('pwaPill');
const apiPill = document.getElementById('apiPill');

const foodInput = document.getElementById('foodInput');
const funInput = document.getElementById('funInput');
const gasInput = document.getElementById('gasInput');
const submitBtn = document.getElementById('submitBtn');

const foodRemainingEl = document.getElementById('foodRemaining');
const funRemainingEl = document.getElementById('funRemaining');
const gasRemainingEl = document.getElementById('gasRemaining');

const lastFoodSpentEl = document.getElementById('lastFoodSpent');
const lastFoodLeftoverEl = document.getElementById('lastFoodLeftover');
const lastFunSpentEl = document.getElementById('lastFunSpent');
const lastFunLeftoverEl = document.getElementById('lastFunLeftover');
const lastGasSpentEl = document.getElementById('lastGasSpent');
const lastGasLeftoverEl = document.getElementById('lastGasLeftover');

const pendingListEl = document.getElementById('pendingList');
const pendingEmptyEl = document.getElementById('pendingEmpty');

const successMsg = document.getElementById('successMsg');

/* DEBUG ELEMENTS */
const dbgApiBaseEl = document.getElementById('dbgApiBase');
const dbgOnlineEl = document.getElementById('dbgOnline');
const dbgCursorEl = document.getElementById('dbgCursor');
const dbgOutboxEl = document.getElementById('dbgOutbox');
const dbgLedgerEl = document.getElementById('dbgLedger');
const dbgLastSyncEl = document.getElementById('dbgLastSync');
const dbgLastErrEl = document.getElementById('dbgLastErr');

const currency = new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' });

let db = null;
let isSyncing = false;

/* Debug state */
let lastSyncIso = null;
let lastApiError = null;

// Local-only cache of categories (from /api/state)
let categories = [
  { key: "food", name: "Food", default_limit: 50000 },
  { key: "fun", name: "Fun", default_limit: 30000 },
  { key: "gas", name: "Gas", default_limit: 20000 },
];

/* =========================================================
   PWA / SERVICE WORKER
   ========================================================= */

(async function initPwa() {
  try {
    if (!('serviceWorker' in navigator)) {
      pwaPill.textContent = 'PWA: unsupported';
      pwaPill.className = 'pill bad';
      return;
    }

    const reg = await navigator.serviceWorker.register(`./sw.js?v=${encodeURIComponent(SW_VERSION)}`);
    const state = reg.active ? 'active' : (reg.installing ? 'installing' : 'registered');

    pwaPill.textContent = `PWA: ${state}`;
    pwaPill.className = 'pill online';
  } catch (e) {
    console.error(e);
    pwaPill.textContent = 'PWA: SW failed';
    pwaPill.className = 'pill bad';
  }
})();

/* =========================================================
   INDEXEDDB SETUP
   - tx: offline queue items (each has {items:[...]} compatible with /api/expenses/batch)
   - meta: stores { key:'cursor', value:number }
   - ledger: local expenses for offline summary (append-only)
   ========================================================= */

(function initDB(){
  const req = indexedDB.open('budgetDB', 2);
  req.onupgradeneeded = e => {
    const d = e.target.result;
    if (!d.objectStoreNames.contains('tx')) d.createObjectStore('tx', { autoIncrement: true });
    if (!d.objectStoreNames.contains('meta')) d.createObjectStore('meta', { keyPath: 'key' });
    if (!d.objectStoreNames.contains('ledger')) d.createObjectStore('ledger', { keyPath: 'client_id' });
  };
  req.onsuccess = e => {
    db = e.target.result;
    loadPending();
    refreshDebug().catch(() => {});
    loadSummary().catch(console.error);
  };
  req.onerror = () => console.error('IndexedDB error');
})();

/* =========================================================
   STATUS HELPERS
   ========================================================= */

function setApiStatus(text, isBad) {
  apiPill.textContent = text;
  apiPill.className = `pill ${isBad ? 'bad' : 'online'}`;
}

function setNetStatus(extraLabel) {
  if (isSyncing) {
    netStatusPill.textContent = extraLabel || 'Syncing…';
    netStatusPill.className = 'pill syncing';
    return;
  }
  const online = navigator.onLine;
  netStatusPill.textContent = online ? 'Online' : 'Offline';
  netStatusPill.className = `pill ${online ? 'online' : 'offline'}`;
}

function centsFromDollars(d) {
  return Math.round(Number(d) * 100);
}

function dollarsFromCents(c) {
  return (Number(c) || 0) / 100;
}

function nowIso() {
  return new Date().toISOString();
}

function uuid() {
  if (crypto && typeof crypto.randomUUID === "function") return crypto.randomUUID();
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

/* =========================================================
   DEBUG HELPERS
   ========================================================= */

function setLastApiError(err) {
  lastApiError = err ? String(err.message || err) : null;
  if (dbgLastErrEl) dbgLastErrEl.textContent = lastApiError || '(none)';
}

function setLastSyncNow() {
  lastSyncIso = new Date().toISOString();
  if (dbgLastSyncEl) dbgLastSyncEl.textContent = lastSyncIso;
}

function countStore(storeName) {
  return new Promise((resolve) => {
    if (!db) return resolve(0);
    const tx = db.transaction(storeName, 'readonly');
    const store = tx.objectStore(storeName);

    if (typeof store.count === 'function') {
      const req = store.count();
      req.onsuccess = () => resolve(req.result || 0);
      req.onerror = () => resolve(0);
    } else {
      const req = store.getAll();
      req.onsuccess = () => resolve((req.result || []).length);
      req.onerror = () => resolve(0);
    }
  });
}

async function refreshDebug() {
  try {
    if (dbgApiBaseEl) dbgApiBaseEl.textContent = API_BASE;
    if (dbgOnlineEl) dbgOnlineEl.textContent = navigator.onLine ? 'true' : 'false';

    const cursor = Number((await getMeta('cursor')) || 0);
    if (dbgCursorEl) dbgCursorEl.textContent = String(cursor);

    const outboxCount = await countStore('tx');
    if (dbgOutboxEl) dbgOutboxEl.textContent = String(outboxCount);

    const ledgerCount = await countStore('ledger');
    if (dbgLedgerEl) dbgLedgerEl.textContent = String(ledgerCount);

    if (dbgLastSyncEl) dbgLastSyncEl.textContent = lastSyncIso || '(not yet)';
    if (dbgLastErrEl) dbgLastErrEl.textContent = lastApiError || '(none)';
  } catch {
    // debug must never break the app
  }
}

/* =========================================================
   API CALLS (Worker)
   ========================================================= */

async function apiGet(path) {
  setApiStatus(`API: GET ${path}…`, false);

  const resp = await fetch(`${API_BASE}${path}`, {
    method: "GET",
    mode: "cors",
    cache: "no-store",
    headers: { "Authorization": `Bearer ${AUTH_TOKEN}` }
  });

  const text = await resp.text();
  let json;
  try { json = JSON.parse(text); }
  catch {
    setApiStatus(`API: non-JSON (HTTP ${resp.status})`, true);
    setLastApiError(`Non-JSON (HTTP ${resp.status})`);
    throw new Error(`Non-JSON response (HTTP ${resp.status}): ${text.slice(0, 200)}`);
  }

  if (!resp.ok || json?.ok === false) {
    setApiStatus(`API: error (HTTP ${resp.status})`, true);
    setLastApiError(json?.error || `HTTP ${resp.status}`);
    throw new Error(json?.error || `HTTP ${resp.status}`);
  }

  setApiStatus(`API: OK`, false);
  setLastApiError(null);
  return json;
}

async function apiHealth() {
  setApiStatus(`API: health…`, false);
  const resp = await fetch(`${API_BASE}/api/health`, { method: "GET", mode: "cors", cache: "no-store" });

  const text = await resp.text();
  let json;
  try { json = JSON.parse(text); }
  catch {
    setApiStatus(`API: non-JSON (HTTP ${resp.status})`, true);
    setLastApiError(`Non-JSON (HTTP ${resp.status})`);
    throw new Error(`Non-JSON response (HTTP ${resp.status}): ${text.slice(0, 200)}`);
  }

  if (!resp.ok || json?.ok === false) {
    setApiStatus(`API: health failed`, true);
    setLastApiError(json?.error || `HTTP ${resp.status}`);
    throw new Error(json?.error || `HTTP ${resp.status}`);
  }

  setApiStatus(`API: OK`, false);
  setLastApiError(null);
  return json;
}

async function apiPostJson(path, payload) {
  setApiStatus(`API: POST ${path}…`, false);

  const resp = await fetch(`${API_BASE}${path}`, {
    method: "POST",
    mode: "cors",
    cache: "no-store",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${AUTH_TOKEN}`
    },
    body: JSON.stringify(payload),
  });

  const text = await resp.text();
  let json;
  try { json = JSON.parse(text); }
  catch {
    setApiStatus(`API: non-JSON (HTTP ${resp.status})`, true);
    setLastApiError(`Non-JSON (HTTP ${resp.status})`);
    throw new Error(`Non-JSON response (HTTP ${resp.status}): ${text.slice(0, 200)}`);
  }

  if (!resp.ok || json?.ok === false) {
    setApiStatus(`API: error (HTTP ${resp.status})`, true);
    setLastApiError(json?.error || `HTTP ${resp.status}`);
    throw new Error(json?.error || `HTTP ${resp.status}`);
  }

  setApiStatus(`API: OK`, false);
  setLastApiError(null);
  return json;
}

/* =========================================================
   LOCAL META (cursor)
   ========================================================= */

function getMeta(key) {
  return new Promise((resolve, reject) => {
    if (!db) return resolve(null);
    const tx = db.transaction('meta', 'readonly');
    const store = tx.objectStore('meta');
    const req = store.get(key);
    req.onsuccess = () => resolve(req.result ? req.result.value : null);
    req.onerror = () => reject(req.error);
  });
}

function setMeta(key, value) {
  return new Promise((resolve, reject) => {
    if (!db) return resolve();
    const tx = db.transaction('meta', 'readwrite');
    tx.objectStore('meta').put({ key, value });
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

/* =========================================================
   LEDGER (local expenses)
   ========================================================= */

function upsertLedgerItems(items) {
  return new Promise((resolve, reject) => {
    if (!db) return resolve();
    const tx = db.transaction('ledger', 'readwrite');
    const store = tx.objectStore('ledger');
    for (const it of items) store.put(it);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

function getAllLedger() {
  return new Promise((resolve, reject) => {
    if (!db) return resolve([]);
    const tx = db.transaction('ledger', 'readonly');
    const store = tx.objectStore('ledger');
    const req = store.getAll();
    req.onsuccess = () => resolve(req.result || []);
    req.onerror = () => reject(req.error);
  });
}

/* =========================================================
   UI HELPERS
   ========================================================= */

function showSuccess(text) {
  successMsg.textContent = text || 'Saved';
  successMsg.style.display = 'block';
  setTimeout(() => { successMsg.style.display = 'none'; }, 2000);
}

function updateButtonState() {
  submitBtn.disabled = (!foodInput.value && !funInput.value && !gasInput.value);
}

/* =========================================================
   CLIENT-SIDE SUMMARY (offline-first)
   ========================================================= */

function computeSummaryFromLedger(ledgerItems) {
  const spentCents = { food: 0, fun: 0, gas: 0 };

  for (const e of ledgerItems) {
    const k = e.category_key;
    if (k in spentCents) spentCents[k] += Number(e.amount || 0);
  }

  const remainingCents = {
    food: centsFromDollars(DEFAULT_BUDGETS.food) - spentCents.food,
    fun:  centsFromDollars(DEFAULT_BUDGETS.fun)  - spentCents.fun,
    gas:  centsFromDollars(DEFAULT_BUDGETS.gas)  - spentCents.gas,
  };

  return {
    FoodRemaining: dollarsFromCents(remainingCents.food),
    FunRemaining:  dollarsFromCents(remainingCents.fun),
    GasRemaining:  dollarsFromCents(remainingCents.gas),

    LastPeriodFoodSpent: 0,
    LastPeriodFoodLeftover: 0,
    LastPeriodFunSpent: 0,
    LastPeriodFunLeftover: 0,
    LastPeriodGasSpent: 0,
    LastPeriodGasLeftover: 0,
  };
}

function renderSummary(summary) {
  foodRemainingEl.textContent = currency.format(summary.FoodRemaining ?? 0);
  funRemainingEl.textContent = currency.format(summary.FunRemaining ?? 0);
  gasRemainingEl.textContent = currency.format(summary.GasRemaining ?? 0);

  lastFoodSpentEl.textContent = currency.format(summary.LastPeriodFoodSpent ?? 0);
  lastFoodLeftoverEl.textContent = currency.format(summary.LastPeriodFoodLeftover ?? 0);

  lastFunSpentEl.textContent = currency.format(summary.LastPeriodFunSpent ?? 0);
  lastFunLeftoverEl.textContent = currency.format(summary.LastPeriodFunLeftover ?? 0);

  lastGasSpentEl.textContent = currency.format(summary.LastPeriodGasSpent ?? 0);
  lastGasLeftoverEl.textContent = currency.format(summary.LastPeriodGasLeftover ?? 0);
}

async function loadSummary() {
  setNetStatus();

  // Always render from local ledger first
  try {
    const ledger = await getAllLedger();
    renderSummary(computeSummaryFromLedger(ledger));
  } catch (e) {
    console.error(e);
  }

  // Then, if online, sync and re-render
  if (navigator.onLine) {
    try {
      await syncNow();
      const ledger = await getAllLedger();
      renderSummary(computeSummaryFromLedger(ledger));
    } catch (e) {
      console.error(e);
    }
  }

  refreshDebug().catch(() => {});
}

/* =========================================================
   PENDING LIST (IndexedDB tx)
   ========================================================= */

function loadPending() {
  if (!db) return;

  const store = db.transaction('tx', 'readonly').objectStore('tx');
  const items = [];

  store.openCursor().onsuccess = e => {
    const c = e.target.result;
    if (c) {
      items.push(c.value);
      c.continue();
    } else {
      items.reverse();
      renderPending(items);
    }
  };
}

function renderPending(items) {
  pendingListEl.innerHTML = '';

  if (!items.length) {
    pendingEmptyEl.style.display = 'block';
    return;
  }

  pendingEmptyEl.style.display = 'none';
  for (const it of items) {
    const totals = { food: 0, fun: 0, gas: 0 };
    for (const exp of (it.items || [])) {
      if (exp.category_key in totals) totals[exp.category_key] += exp.amount;
    }
    const li = document.createElement('li');
    li.textContent =
      `Food: ${currency.format(dollarsFromCents(totals.food))}  |  Fun: ${currency.format(dollarsFromCents(totals.fun))}  |  Gas: ${currency.format(dollarsFromCents(totals.gas))}`;
    pendingListEl.appendChild(li);
  }
}

function enqueueOfflineBatch(batch) {
  if (!db) return;
  db.transaction('tx','readwrite').objectStore('tx').add(batch);
  loadPending();
  refreshDebug().catch(() => {}); // EXTRA DEBUG ADDITION
}

/* =========================================================
   SUBMIT HANDLING (offline-first)
   ========================================================= */

async function submitExpenses(foodDollars, funDollars, gasDollars) {
  const items = [];
  const occurred_at = nowIso();
  const created_by = "pwa";

  if (foodDollars !== 0) items.push({
    client_id: uuid(),
    category_key: "food",
    amount: centsFromDollars(foodDollars),
    note: null,
    occurred_at,
    created_by
  });

  if (funDollars !== 0) items.push({
    client_id: uuid(),
    category_key: "fun",
    amount: centsFromDollars(funDollars),
    note: null,
    occurred_at,
    created_by
  });

  if (gasDollars !== 0) items.push({
    client_id: uuid(),
    category_key: "gas",
    amount: centsFromDollars(gasDollars),
    note: null,
    occurred_at,
    created_by
  });

  if (!items.length) return;

  // Write to local ledger immediately
  await upsertLedgerItems(items);

  // Put in outbox for guaranteed delivery
  const batch = { items };
  enqueueOfflineBatch(batch);

  // Try to sync immediately if online
  if (navigator.onLine) {
    try {
      await syncNow();
      showSuccess('Saved');
    } catch (e) {
      console.error(e);
      showSuccess('Saved offline (will sync)');
    }
  } else {
    showSuccess('Saved offline (will sync)');
  }

  refreshDebug().catch(() => {});
}

/* =========================================================
   SYNC ENGINE
   ========================================================= */

async function loadState() {
  const state = await apiGet('/api/state');
  categories = state.categories || categories;
  return state;
}

async function pushQueueOnce() {
  if (!db) return;

  const tx = db.transaction('tx', 'readwrite');
  const store = tx.objectStore('tx');

  return new Promise((resolve, reject) => {
    const req = store.openCursor();
    req.onsuccess = async (e) => {
      const cursor = e.target.result;
      if (!cursor) return resolve();

      const batch = cursor.value;

      try {
        await apiPostJson('/api/expenses/batch', batch);
        store.delete(cursor.key);
        refreshDebug().catch(() => {}); // EXTRA DEBUG ADDITION (after successful deletion)
        cursor.continue();
      } catch (err) {
        reject(err);
      }
    };
    req.onerror = () => reject(req.error);
  });
}

async function pullChanges() {
  const since = Number((await getMeta('cursor')) || 0);
  const res = await apiGet(`/api/changes?since=${encodeURIComponent(String(since))}`);

  if (Array.isArray(res.expenses) && res.expenses.length) {
    await upsertLedgerItems(res.expenses);
  }

  if (typeof res.cursor === "number") {
    await setMeta('cursor', res.cursor);
  }

  return res;
}

async function syncNow() {
  if (!navigator.onLine) return;

  isSyncing = true;
  setNetStatus('Syncing…');
  refreshDebug().catch(() => {});

  try {
    await apiHealth();
    await loadState();
    await pushQueueOnce();
    await pullChanges();

    setLastSyncNow();
    loadPending();
    setNetStatus();
    await refreshDebug();
  } finally {
    isSyncing = false;
    setNetStatus();
    refreshDebug().catch(() => {});
  }
}

/* =========================================================
   INIT + EVENT WIRING
   ========================================================= */

submitBtn.addEventListener('click', async (e) => {
  e.preventDefault();

  const food = Number(foodInput.value) || 0;
  const fun  = Number(funInput.value) || 0;
  const gas  = Number(gasInput.value) || 0;

  foodInput.value = '';
  funInput.value = '';
  gasInput.value = '';
  updateButtonState();

  if (food === 0 && fun === 0 && gas === 0) return;

  try {
    await submitExpenses(food, fun, gas);
    await loadSummary();
  } catch (err) {
    console.error(err);
    setLastApiError(err);
  }
});

foodInput.addEventListener('input', updateButtonState);
funInput.addEventListener('input', updateButtonState);
gasInput.addEventListener('input', updateButtonState);

window.addEventListener('online', () => {
  setNetStatus();
  refreshDebug().catch(() => {});
  syncNow().catch(err => { console.error(err); setLastApiError(err); });
});

window.addEventListener('offline', () => {
  isSyncing = false;
  setNetStatus();
  refreshDebug().catch(() => {});
});

// Periodic sync while app open (lightweight)
setInterval(() => {
  if (navigator.onLine) syncNow().catch(() => {});
  refreshDebug().catch(() => {});
}, 25000);

setNetStatus();
updateButtonState();
setApiStatus("API: ready", false);
refreshDebug().catch(() => {});

// Initial sync + render
(async function boot() {
  try {
    await syncNow();
  } catch (e) {
    console.error(e);
    setLastApiError(e);
  } finally {
    await loadSummary();
    refreshDebug().catch(() => {});
  }
})();
</script>
</body>
</html>
