<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="theme-color" content="#0b1320" />
<title>Purrfect Budget</title>

<style>
:root{
  --bg0:#070b12; --bg1:#0b1320;
  --border:rgba(255,255,255,.10);
  --text:#e9eef7; --muted:rgba(233,238,247,.75);
  --danger:#ffb4b4; --ok:#b6ffcf;
  --radius:16px;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  color:var(--text);
  background:
    radial-gradient(900px 480px at 10% 0%, rgba(45,108,223,.22), transparent 60%),
    radial-gradient(720px 360px at 90% 10%, rgba(182,255,207,.10), transparent 60%),
    linear-gradient(180deg,var(--bg0),var(--bg1));
}
.wrap{max-width:1100px;margin:0 auto;padding:18px}
h1{font-size:18px;margin:0 0 10px}
.card{
  background:linear-gradient(180deg,rgba(255,255,255,.07),rgba(255,255,255,.045));
  border:1px solid var(--border);
  border-radius:var(--radius);
  padding:16px;
}
.subcard{margin-top:14px}
.hidden{display:none!important}
.row{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
label{font-size:13px;color:var(--muted);margin-top:10px;display:block}
input,select{
  width:100%;padding:10px;border-radius:12px;
  background:rgba(0,0,0,.35);color:var(--text);
  border:1px solid var(--border)
}
button{
  border:0;border-radius:12px;padding:10px 14px;
  font-weight:600;color:#fff;cursor:pointer;
  background:linear-gradient(180deg,#2d6cdf,#1f57c8)
}
button.secondary{background:rgba(255,255,255,.12)}
button.danger{background:rgba(255,180,180,.18);color:#ffd7d7}
button:disabled{opacity:.55}
.status{font-size:13px;color:var(--muted);margin-top:8px;white-space:pre-wrap}
.status.ok{color:var(--ok)}
.status.error{color:var(--danger)}
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:16px}
@media(max-width:900px){.grid2{grid-template-columns:1fr}}

table{width:100%;border-collapse:collapse;margin-top:10px}
th,td{padding:6px;border-bottom:1px solid var(--border)}
th{text-align:left;font-size:13px;color:var(--muted)}
td.right{text-align:right}
td.center, th.center{text-align:center}
.tableScroll{max-height:360px;overflow:auto}

.fabWrap{
  display:flex;
  justify-content:space-between;
  gap:10px;
  margin-top:14px;
}
.historyBtn{
  background:linear-gradient(180deg,#2d6cdf,#1f57c8);
}
.settingsBtn{
  background:linear-gradient(180deg,#2d6cdf,#1f57c8);
}

.modalOverlay{
  position:fixed;inset:0;background:rgba(0,0,0,.6);
  display:flex;align-items:flex-start;justify-content:center;
  padding:18px;z-index:100
}
.modal{
  max-width:780px;width:100%;
  max-height:calc(100vh - 36px);
  overflow:auto;
  background:var(--bg1);
  border:1px solid var(--border);
  border-radius:16px;
  padding:16px;
}
.modalHeader{display:flex;justify-content:space-between;align-items:center;gap:10px}
.divider{height:1px;background:rgba(255,255,255,.10);margin:12px 0}
.small{font-size:12px;color:var(--muted)}
</style>
</head>

<body>
<div class="wrap">

  <!-- AUTH -->
  <div id="authView" class="card hidden">
    <label>Your name</label>
    <input id="userNameInput" autocomplete="off" />
    <label>Bearer token</label>
    <input id="tokenInput" type="password" autocomplete="off" />
    <div class="row">
      <button id="saveTokenBtn" type="button">Continue</button>
      <button id="toggleTokenBtn" class="secondary" type="button">Show</button>
    </div>
    <div id="authStatus" class="status"></div>
  </div>

  <!-- SETUP WIZARD -->
  <div id="noCategoriesView" class="hidden">
    <div id="wizStep1" class="card">
      <h1>Step 1 — Budget period</h1>

      <label>Period type</label>
      <select id="wizPeriodType">
        <option value="daily">Daily</option>
        <option value="weekly">Weekly</option>
        <option value="biweekly" selected>Every Two Weeks</option>
        <option value="semi_monthly">Twice a Month</option>
        <option value="monthly">Monthly</option>
        <option value="quarterly">Quarterly</option>
      </select>

      <label>Start date (MM-DD-YYYY)</label>
      <input id="wizStartDate" placeholder="MM-DD-YYYY" />

      <div class="row">
        <button id="wizNext1" type="button">Next</button>
      </div>
      <div id="wizStatus1" class="status"></div>
    </div>

    <div id="wizStep2" class="card hidden">
      <h1>Step 2 — Categories</h1>
      <div id="wizCatList"></div>
      <div class="row">
        <button id="wizAddCat" class="secondary" type="button">Add Category</button>
        <button id="wizSubmit" type="button">Initialize Budget</button>
      </div>
      <div id="wizStatus2" class="status"></div>
    </div>
  </div>
  <!-- APP -->
  <div id="appView" class="hidden">
    <div id="dashboardView" class="hidden">

      <!-- Budget Summary (Remaining 2nd col, Spent 3rd; both centered) -->
      <div class="card">
        <h1>Budget Summary</h1>
        <div class="status">Period: <strong id="periodLabel">—</strong></div>

        <div class="tableScroll">
          <table>
            <thead>
              <tr>
                <th>Category</th>
                <th class="center">Remaining</th>
                <th class="center">Spent</th>
              </tr>
            </thead>
            <tbody id="catTableBody"></tbody>
          </table>
        </div>
      </div>

      <div class="grid2">
        <div class="card subcard">
          <h1>Add Transaction</h1>

          <label>Type</label>
          <select id="txType">
            <option value="expense">Expense</option>
            <option value="refund">Refund</option>
            <option value="transfer">Transfer</option>
          </select>

          <!-- Expense/Refund -->
          <div id="txStandardPanel">
            <label>Category</label>
            <select id="txCategory"></select>

            <label>Amount</label>
            <input id="txAmount" placeholder="$0.00" inputmode="decimal" />

            <label>Note</label>
            <input id="txNote" />
          </div>

          <!-- Transfer -->
          <div id="txTransferPanel" class="hidden">
            <label>Transfer from</label>
            <select id="txFromCategory"></select>

            <label>Transfer to</label>
            <select id="txToCategory"></select>

            <label>Amount</label>
            <input id="txTransferAmount" placeholder="$0.00" inputmode="decimal" />

            <label>Note (optional)</label>
            <input id="txTransferNote" placeholder="e.g. moved budget to cover overage" />
          </div>

          <div class="row">
            <button id="txSubmitBtn" type="button">Save</button>
          </div>
          <div id="txStatus" class="status"></div>
        </div>
      </div>

      <!-- Floating buttons -->
      <div class="fabWrap">
        <button id="openHistoryBtn" type="button" class="historyBtn">History</button>
        <button id="openSettingsBtn" type="button" class="settingsBtn">Settings</button>
      </div>

    </div>
  </div>

  <div id="globalStatus" class="status"></div>
</div>

<!-- SETTINGS MODAL -->
<div id="settingsOverlay" class="modalOverlay hidden" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true">
    <div class="modalHeader">
      <h1 style="margin:0;">Settings</h1>
      <button id="settingsCloseBtn" class="secondary" type="button">Close</button>
    </div>

    <div class="divider"></div>

    <div class="card">
      <h1>Budget Settings</h1>
      
      <div class="row">
        <button id="settingsOpenEditBudgetsBtn" class="secondary" type="button">Edit Budget Amounts</button>
      </div>

      <div id="settingsEditBudgetsPanel" class="subcard hidden">
        <div class="status" style="margin-top:0;">
          Adjust the budget amounts for your categories. This affects the current period.
        </div>
        <div id="settingsEditBudgetsList"></div>
        <div class="row">
          <button id="settingsSaveEditBudgetsBtn" type="button">Save Changes</button>
          <button id="settingsCancelEditBudgetsBtn" class="secondary" type="button">Cancel</button>
        </div>
        <div id="settingsEditBudgetsStatus" class="status"></div>
      </div>

      <div class="row" style="margin-top:14px;">
        <button id="settingsOpenReorderBtn" class="secondary" type="button">Reorder Categories</button>
      </div>

      <div id="settingsReorderPanel" class="subcard hidden">
        <div class="status" style="margin-top:0;">
          Move categories up/down. This affects how categories are shown in the app on this device.
        </div>
        <div id="settingsReorderList"></div>
        <div class="row">
          <button id="settingsSaveOrderBtn" type="button">Save Order</button>
          <button id="settingsCancelOrderBtn" class="secondary" type="button">Cancel</button>
        </div>
        <div id="settingsReorderStatus" class="status"></div>
      </div>

      <!-- Add Budget Categories -->
      <div class="subcard" style="margin-top:14px;">
        <div class="row">
          <button id="settingsOpenAddCatsBtn" class="secondary" type="button">Add Budget Categories</button>
        </div>

        <div id="settingsAddCatsPanel" class="subcard hidden" style="margin-top:10px;">
          <div class="status" style="margin-top:0;">
            Add one or more categories with their starting budget amounts.
          </div>

          <div id="settingsAddCatsList"></div>

          <div class="row">
            <button id="settingsAddCatsRowBtn" class="secondary" type="button">Add Row</button>
          </div>

          <div class="row">
            <button id="settingsSaveCatsBtn" type="button">Save Categories</button>
            <button id="settingsCancelCatsBtn" class="secondary" type="button">Cancel</button>
          </div>

          <div id="settingsAddCatsStatus" class="status"></div>
        </div>
      </div>
    </div>

    <div class="card subcard">
      <h1>Account</h1>
      <div class="row">
        <button id="settingsLogoutBtn" class="secondary" type="button">Log Out</button>
        <button id="settingsResetBtn" class="danger" type="button">Reset Budget</button>
      </div>
      <div class="small" style="margin-top:8px;">
        Reset clears categories, budgets, and all transaction history from the server.
      </div>
      <div id="settingsAccountStatus" class="status"></div>
    </div>
  </div>
</div>

<!-- HISTORY MODAL -->
<div id="historyOverlay" class="modalOverlay hidden" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true">
    <div class="modalHeader">
      <h1 id="historyTitle" style="margin:0;">History</h1>
      <button id="historyCloseBtn" class="secondary" type="button">Close</button>
    </div>

    <div class="divider"></div>

    <div class="row" style="margin-top:0;">
      <button id="historyCurrentBtn" class="secondary" type="button">Current Period</button>
      <button id="historyPriorBtn" class="secondary" type="button">Prior Period</button>
    </div>

    <div id="historyStatus" class="status"></div>

    <div class="tableScroll" style="margin-top:10px;">
      <table>
        <thead>
          <tr>
            <th>Date</th>
            <th>Who</th>
            <th>Type</th>
            <th>Category</th>
            <th class="right">Amount</th>
            <th>Note</th>
          </tr>
        </thead>
        <tbody id="historyBody"></tbody>
      </table>
    </div>
  </div>
</div>

<script>
/* ================= CONFIG ================= */
const API = {
  base: "https://purrfect-budget-api.kardian.workers.dev",
  validate: "/api/auth/validate",
  state: "/api/budget/state",
  init: "/api/budget/init",
  tx: "/api/budget/transactions",
  categories: "/api/budget/categories",
  reset: "/api/budget/reset",
  timeoutMs: 12000
};

/* ================= DOM ================= */
const $ = (id) => document.getElementById(id);

const authView = $("authView");
const userNameInput = $("userNameInput");
const tokenInput = $("tokenInput");
const saveTokenBtn = $("saveTokenBtn");
const toggleTokenBtn = $("toggleTokenBtn");
const authStatus = $("authStatus");

const noCategoriesView = $("noCategoriesView");
const wizStep1 = $("wizStep1");
const wizStep2 = $("wizStep2");
const wizPeriodType = $("wizPeriodType");
const wizStartDate = $("wizStartDate");
const wizCatList = $("wizCatList");
const wizNext1 = $("wizNext1");
const wizAddCat = $("wizAddCat");
const wizSubmit = $("wizSubmit");
const wizStatus1 = $("wizStatus1");
const wizStatus2 = $("wizStatus2");

const appView = $("appView");
const dashboardView = $("dashboardView");
const periodLabel = $("periodLabel");
const catTableBody = $("catTableBody");

const txType = $("txType");
const txStandardPanel = $("txStandardPanel");
const txTransferPanel = $("txTransferPanel");

const txCategory = $("txCategory");
const txAmount = $("txAmount");
const txNote = $("txNote");

const txFromCategory = $("txFromCategory");
const txToCategory = $("txToCategory");
const txTransferAmount = $("txTransferAmount");
const txTransferNote = $("txTransferNote");

const txSubmitBtn = $("txSubmitBtn");
const txStatus = $("txStatus");

const globalStatus = $("globalStatus");

const openSettingsBtn = $("openSettingsBtn");
const settingsOverlay = $("settingsOverlay");
const settingsCloseBtn = $("settingsCloseBtn");

const settingsOpenReorderBtn = $("settingsOpenReorderBtn");
const settingsReorderPanel = $("settingsReorderPanel");
const settingsReorderList = $("settingsReorderList");
const settingsSaveOrderBtn = $("settingsSaveOrderBtn");
const settingsCancelOrderBtn = $("settingsCancelOrderBtn");
const settingsReorderStatus = $("settingsReorderStatus");

const settingsOpenEditBudgetsBtn = $("settingsOpenEditBudgetsBtn");
const settingsEditBudgetsPanel = $("settingsEditBudgetsPanel");
const settingsEditBudgetsList = $("settingsEditBudgetsList");
const settingsSaveEditBudgetsBtn = $("settingsSaveEditBudgetsBtn");
const settingsCancelEditBudgetsBtn = $("settingsCancelEditBudgetsBtn");
const settingsEditBudgetsStatus = $("settingsEditBudgetsStatus");

const settingsOpenAddCatsBtn = $("settingsOpenAddCatsBtn");
const settingsAddCatsPanel = $("settingsAddCatsPanel");
const settingsAddCatsList = $("settingsAddCatsList");
const settingsAddCatsRowBtn = $("settingsAddCatsRowBtn");
const settingsSaveCatsBtn = $("settingsSaveCatsBtn");
const settingsCancelCatsBtn = $("settingsCancelCatsBtn");
const settingsAddCatsStatus = $("settingsAddCatsStatus");

const settingsLogoutBtn = $("settingsLogoutBtn");
const settingsResetBtn = $("settingsResetBtn");
const settingsAccountStatus = $("settingsAccountStatus");

/* History DOM */
const openHistoryBtn = $("openHistoryBtn");
const historyOverlay = $("historyOverlay");
const historyCloseBtn = $("historyCloseBtn");
const historyCurrentBtn = $("historyCurrentBtn");
const historyPriorBtn = $("historyPriorBtn");
const historyStatus = $("historyStatus");
const historyBody = $("historyBody");
const historyTitle = $("historyTitle");

/* ================= UI HELPERS ================= */
function show(el){ if (el) el.classList.remove("hidden"); }
function hide(el){ if (el) el.classList.add("hidden"); }

function setStatus(el, msg, kind){
  if (!el) return;
  el.textContent = msg || "";
  el.classList.remove("ok","error");
  if (kind) el.classList.add(kind);
}

function join(path){
  return API.base.replace(/\/+$/,"") + "/" + path.replace(/^\/+/,"");
}

function authHeaders(token){
  return { Authorization:`Bearer ${token}`, "Content-Type":"application/json" };
}

function fetchWithTimeout(url, options = {}){
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), API.timeoutMs);
  return fetch(url, { ...options, signal: controller.signal }).finally(() => clearTimeout(id));
}

async function safeText(resp){
  try { return await resp.text(); } catch { return ""; }
}
</script>
<script>
/* ================= INDEXEDDB (ROBUST) ================= */
const IDB = { name:"pwa-budget-app", version:4, store:"kv" };
const KEY_TOKEN = "token";
const KEY_NAME  = "name";
const KEY_CAT_ORDER = "catOrder"; // array of category_id numbers in desired UI order

function deleteDb(){
  return new Promise((resolve) => {
    const del = indexedDB.deleteDatabase(IDB.name);
    del.onsuccess = () => resolve(true);
    del.onerror = () => resolve(false);
    del.onblocked = () => resolve(false);
  });
}

function openDbOnce(versionOverride){
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(IDB.name, versionOverride ?? IDB.version);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(IDB.store)) db.createObjectStore(IDB.store);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function openDb(){
  try {
    const db = await openDbOnce();
    if (!db.objectStoreNames.contains(IDB.store)) {
      db.close();
      await deleteDb();
      return await openDbOnce();
    }
    return db;
  } catch (e) {
    const msg = String(e?.message || e || "");
    if (msg.includes("higher version")) {
      await deleteDb();
      return await openDbOnce();
    }
    throw e;
  }
}

async function idbGet(key){
  const db = await openDb();
  try {
    return await new Promise((resolve, reject) => {
      const tx = db.transaction(IDB.store, "readonly");
      const store = tx.objectStore(IDB.store);
      const req = store.get(key);
      req.onsuccess = () => resolve(req.result ?? null);
      req.onerror = () => reject(req.error);
    });
  } finally { db.close(); }
}

async function idbSet(key, value){
  const db = await openDb();
  try {
    return await new Promise((resolve, reject) => {
      const tx = db.transaction(IDB.store, "readwrite");
      const store = tx.objectStore(IDB.store);
      const req = store.put(value, key);
      req.onsuccess = () => resolve(true);
      req.onerror = () => reject(req.error);
    });
  } finally { db.close(); }
}

async function idbDel(key){
  const db = await openDb();
  try {
    return await new Promise((resolve, reject) => {
      const tx = db.transaction(IDB.store, "readwrite");
      const store = tx.objectStore(IDB.store);
      const req = store.delete(key);
      req.onsuccess = () => resolve(true);
      req.onerror = () => reject(req.error);
    });
  } finally { db.close(); }
}
</script>

<script>
/* ================= API ================= */
async function validateToken(token){
  const url = join(API.validate);
  const resp = await fetchWithTimeout(url, { method:"GET", headers: authHeaders(token) });
  if (resp.ok) return true;
  if (resp.status === 401 || resp.status === 403) return false;
  const t = await safeText(resp);
  throw new Error(`Token validate failed (${resp.status}): ${t || resp.statusText}`);
}

async function fetchState(token){
  const url = join(API.state);
  const resp = await fetchWithTimeout(url, { method:"GET", headers: authHeaders(token) });
  if (!resp.ok){
    if (resp.status === 401 || resp.status === 403) return { authFailed:true, state:null };
    const t = await safeText(resp);
    throw new Error(`State failed (${resp.status}): ${t || resp.statusText}`);
  }
  return { authFailed:false, state: await resp.json().catch(()=> ({})) };
}

async function postInit(token, payload){
  const url = join(API.init);
  const resp = await fetchWithTimeout(url, { method:"POST", headers: authHeaders(token), body: JSON.stringify(payload) });
  if (!resp.ok){
    if (resp.status === 401 || resp.status === 403) return { authFailed:true, result:null };
    const t = await safeText(resp);
    throw new Error(`Init failed (${resp.status}): ${t || resp.statusText}`);
  }
  return { authFailed:false, result: await resp.json().catch(()=> ({})) };
}

async function postTransaction(token, payload){
  const url = join(API.tx);
  const resp = await fetchWithTimeout(url, { method:"POST", headers: authHeaders(token), body: JSON.stringify(payload) });
  if (!resp.ok){
    if (resp.status === 401 || resp.status === 403) return { authFailed:true, result:null };
    const t = await safeText(resp);
    throw new Error(`Transaction failed (${resp.status}): ${t || resp.statusText}`);
  }
  return { authFailed:false, result: await resp.json().catch(()=> ({})) };
}

async function postReset(token){
  const url = join(API.reset);
  const resp = await fetchWithTimeout(url, {
    method:"POST",
    headers: authHeaders(token),
    body: JSON.stringify({ confirm:"RESET" })
  });
  if (!resp.ok){
    if (resp.status === 401 || resp.status === 403) return { authFailed:true, result:null };
    const t = await safeText(resp);
    throw new Error(`Reset failed (${resp.status}): ${t || resp.statusText}`);
  }
  return { authFailed:false, result: await resp.json().catch(()=> ({})) };
}

async function postCategories(token, payload){
  const url = join(API.categories);
  const resp = await fetchWithTimeout(url, {
    method:"POST",
    headers: authHeaders(token),
    body: JSON.stringify(payload)
  });
  if (!resp.ok){
    if (resp.status === 401 || resp.status === 403) return { authFailed:true, result:null };
    const t = await safeText(resp);
    throw new Error(`Categories failed (${resp.status}): ${t || resp.statusText}`);
  }
  return { authFailed:false, result: await resp.json().catch(()=> ({})) };
}

async function fetchTransactions(token, opts = {}){
  const url = new URL(join(API.tx));
  if (opts?.sinceMs) url.searchParams.set("since", String(opts.sinceMs));
  if (opts?.limit) url.searchParams.set("limit", String(opts.limit));
  const resp = await fetchWithTimeout(url.toString(), { method:"GET", headers: authHeaders(token) });
  if (!resp.ok){
    if (resp.status === 401 || resp.status === 403) return { authFailed:true, result:null };
    const t = await safeText(resp);
    throw new Error(`Transactions failed (${resp.status}): ${t || resp.statusText}`);
  }
  return { authFailed:false, result: await resp.json().catch(()=> ({})) };
}
</script>

<script>
/* ================= DATE + MONEY ================= */
const pad2 = (n) => String(n).padStart(2, "0");

function todayYMD(){
  const d = new Date();
  return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
}

function ymdToMdy(ymd){
  const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(String(ymd||""));
  if (!m) return "";
  return `${m[2]}-${m[3]}-${m[1]}`;
}

function mdyToYmd(mdy){
  const s = String(mdy||"").trim();
  const m = /^(\d{2})-(\d{2})-(\d{4})$/.exec(s);
  if (!m) return null;
  const mm = Number(m[1]), dd = Number(m[2]), yyyy = Number(m[3]);
  if (yyyy < 1900 || yyyy > 2100) return null;
  const dt = new Date(yyyy, mm-1, dd);
  if (dt.getFullYear() !== yyyy || dt.getMonth() !== (mm-1) || dt.getDate() !== dd) return null;
  return `${yyyy}-${pad2(mm)}-${pad2(dd)}`;
}

function normalizeMoneyDisplay(s){
  const raw = String(s||"").trim().replace(/[^0-9.]/g,""); // strips commas and other non-numeric chars
  if (!raw) return "";
  const n = Number(raw);
  if (!Number.isFinite(n)) return "";
  
  // Format with commas: split into integer and decimal parts
  const formatted = n.toFixed(2);
  const parts = formatted.split('.');
  const integerPart = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  
  return "$" + integerPart + "." + parts[1];
}

function validateAndFixCommas(value){
  // Allow user to type freely, but validate/fix when they're done
  let clean = String(value || "").replace(/[^0-9.,]/g, "");
  
  // Split on decimal point
  const parts = clean.split('.');
  const integerPart = parts[0] || "";
  const decimalPart = parts.length > 1 ? parts[1] : "";
  
  // Remove all commas to get pure digits
  const digitsOnly = integerPart.replace(/,/g, "");
  
  // Always return with proper comma formatting
  const formatted = digitsOnly.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  
  return formatted + (decimalPart ? '.' + decimalPart : '');
}

function dollarsToCentsFromInput(s){
  const raw = String(s||"").trim().replace(/[^0-9.]/g,""); // strips commas and other non-numeric chars
  if (!raw) return null;
  const n = Number(raw);
  if (!Number.isFinite(n) || n <= 0) return null;
  return Math.round(n*100);
}

function fmtCents(c){
  const n = Number(c);
  if (!Number.isFinite(n)) return "—";
  return "$" + (n/100).toFixed(2);
}

function fmtLocalDateTime(iso){
  const s = String(iso || "");
  const d = new Date(s);
  if (!Number.isFinite(d.getTime())) return s || "—";
  return d.toLocaleString(undefined, {
    year:"numeric", month:"2-digit", day:"2-digit",
    hour:"2-digit", minute:"2-digit"
  });
}
</script>

<script>
/* ================= WIZARD ================= */
function showWizardStep(n){
  [wizStep1, wizStep2].forEach((el, idx) => el.classList.toggle("hidden", idx !== n));
}

function addWizRow(name = "", budget = ""){
  const wrap = document.createElement("div");
  wrap.className = "row";
  wrap.style.marginTop = "10px";
  wrap.innerHTML = `
    <input class="wizCatName" placeholder="Category" value="${String(name).replaceAll('"','&quot;')}" />
    <input class="wizCatBudget" placeholder="$0.00" value="${String(budget).replaceAll('"','&quot;')}" inputmode="decimal" />
    <button type="button" class="secondary wizRemoveBtn">Remove</button>
  `;
  const b = wrap.querySelector(".wizCatBudget");
  b.addEventListener("blur", () => { 
    b.value = validateAndFixCommas(b.value);
    b.value = normalizeMoneyDisplay(b.value); 
  });
  wrap.querySelector(".wizRemoveBtn").addEventListener("click", () => wrap.remove());
  wizCatList.appendChild(wrap);
}

function initWizard(){
  wizCatList.innerHTML = "";
  wizStartDate.value = ymdToMdy(todayYMD());
  addWizRow("Groceries", "300.00");
  addWizRow("Gas", "120.00");
  setStatus(wizStatus1, "");
  setStatus(wizStatus2, "");
  showWizardStep(0);
}

function readWizardCategories(){
  const rows = Array.from(wizCatList.querySelectorAll(".row"));
  const cats = [];
  for (const r of rows){
    const name = (r.querySelector(".wizCatName")?.value || "").trim();
    const money = (r.querySelector(".wizCatBudget")?.value || "").trim();
    const dollars = money.replace(/[^0-9.]/g,"");
    if (!name) continue;
    cats.push({ name, sort_order: cats.length + 1, budget_dollars: dollars });
  }
  return cats;
}

function validateWizardStep1(){
  const pt = String(wizPeriodType.value || "").trim();
  const allowed = new Set(["daily","weekly","biweekly","semi_monthly","monthly","quarterly"]);
  if (!allowed.has(pt)) return "Invalid period type.";
  const ymd = mdyToYmd(wizStartDate.value);
  if (!ymd) return "Start date must be MM-DD-YYYY.";
  return null;
}

function validateWizardStep2(){
  const cats = readWizardCategories();
  if (cats.length < 1 || cats.length > 10) return "Please provide 1 to 10 categories.";
  const seen = new Set();
  for (const c of cats){
    if (!c.name) return "Category name cannot be blank.";
    if (!c.budget_dollars) return `Please enter a budget for: ${c.name}`;
    const k = c.name.toLowerCase();
    if (seen.has(k)) return `Duplicate category name: ${c.name}`;
    seen.add(k);
  }
  return null;
}

async function submitInit(){
  const err1 = validateWizardStep1();
  if (err1){ showWizardStep(0); return setStatus(wizStatus1, err1, "error"); }
  const err2 = validateWizardStep2();
  if (err2){ return setStatus(wizStatus2, err2, "error"); }

  const token = await idbGet(KEY_TOKEN);
  if (!token) return showAuth("Missing token. Please re-enter.", true);

  const payload = {
    period_type: String(wizPeriodType.value || "").trim(),
    period_anchor_date: mdyToYmd(wizStartDate.value),
    categories: readWizardCategories()
  };

  setStatus(wizStatus2, "Initializing…");
  try {
    const res = await postInit(token, payload);
    if (res.authFailed){
      await idbDel(KEY_TOKEN);
      return showAuth("Token invalid/expired. Please re-enter.", true);
    }
    setStatus(wizStatus2, "Initialized. Loading…", "ok");
    await bootstrap();
  } catch (e) {
    setStatus(wizStatus2, e?.message || String(e), "error");
  }
}

/* Wizard events */
wizNext1.addEventListener("click", () => {
  const err = validateWizardStep1();
  if (err) return setStatus(wizStatus1, err, "error");
  setStatus(wizStatus1, "");
  showWizardStep(1);
});
wizAddCat.addEventListener("click", () => addWizRow("", ""));
wizSubmit.addEventListener("click", submitInit);
</script>

<script>
/* ================= AUTH/UI FLOW ================= */
function showAuth(message = "", isError = false){
  show(authView);
  hide(appView);
  hide(noCategoriesView);
  hide(dashboardView);
  setStatus(authStatus, message, isError ? "error" : "");
  setStatus(globalStatus, "");
  userNameInput?.focus();
}

function showWizard(){
  hide(authView);
  hide(appView);
  show(noCategoriesView);
  hide(dashboardView);
  initWizard();
}

function showApp(){
  hide(authView);
  hide(noCategoriesView);
  show(appView);
  show(dashboardView);
}

/* Token show/hide */
toggleTokenBtn.addEventListener("click", () => {
  const isPw = tokenInput.type === "password";
  tokenInput.type = isPw ? "text" : "password";
  toggleTokenBtn.textContent = isPw ? "Hide" : "Show";
});

/* Save token */
saveTokenBtn.addEventListener("click", async () => {
  const name = String(userNameInput.value || "").trim().slice(0, 40);
  const token = String(tokenInput.value || "").trim();
  if (!name) return setStatus(authStatus, "Please enter your name.", "error");
  if (!token) return setStatus(authStatus, "Please enter your bearer token.", "error");

  setStatus(authStatus, "Validating…");
  try {
    const ok = await validateToken(token);
    if (!ok) return setStatus(authStatus, "Token invalid.", "error");

    await idbSet(KEY_NAME, name);
    await idbSet(KEY_TOKEN, token);
    setStatus(authStatus, "Saved.", "ok");
    await bootstrap();
  } catch (e) {
    setStatus(authStatus, e?.message || String(e), "error");
  }
});
</script>

<script>
/* ================= CATEGORY ORDERING (UI ONLY) ================= */
function normalizeCategories(state){
  const cats = Array.isArray(state?.categories) ? state.categories : [];
  return cats.map(c => ({
    category_id: Number(c.category_id),
    name: String(c.name || ""),
    spent_cents: Number(c.spent_cents) || 0,
    remaining_cents: Number(c.remaining_cents) || 0
  })).filter(c => Number.isFinite(c.category_id) && c.category_id > 0 && c.name);
}

async function applyUiOrder(cats){
  const saved = await idbGet(KEY_CAT_ORDER);
  if (!Array.isArray(saved) || saved.length === 0) return cats;

  const order = saved.map(Number).filter(n => Number.isFinite(n) && n > 0);
  const byId = new Map(cats.map(c => [c.category_id, c]));

  const out = [];
  const seen = new Set();
  for (const id of order){
    const c = byId.get(id);
    if (c) { out.push(c); seen.add(id); }
  }
  for (const c of cats){
    if (!seen.has(c.category_id)) out.push(c);
  }
  return out;
}

async function ensureOrderDefaults(cats){
  const saved = await idbGet(KEY_CAT_ORDER);

  if (!Array.isArray(saved) || saved.length === 0) {
    await idbSet(KEY_CAT_ORDER, cats.map(c => c.category_id));
    return;
  }

  const order = saved.map(Number).filter(n => Number.isFinite(n) && n > 0);
  const set = new Set(order);
  let changed = false;
  for (const c of cats){
    if (!set.has(c.category_id)) { order.push(c.category_id); set.add(c.category_id); changed = true; }
  }
  if (changed) await idbSet(KEY_CAT_ORDER, order);
}
</script>

<script>
/* ================= DASHBOARD + HISTORY CATEGORY MAP ================= */
let CURRENT_STATE = null;
let HISTORY_CATEGORY_MAP = new Map(); // category_id -> name

async function renderDashboard(state){
  const p = state?.period;
  if (p?.start_ts && p?.end_ts) {
    periodLabel.textContent = `${String(p.start_ts).slice(0,10)} → ${String(p.end_ts).slice(0,10)}`;
  } else {
    periodLabel.textContent = "—";
  }

  let cats = normalizeCategories(state);
  await ensureOrderDefaults(cats);
  cats = await applyUiOrder(cats);

  // Budget summary table
  catTableBody.innerHTML = "";
  for (const c of cats){
    const tr = document.createElement("tr");

    const tdName = document.createElement("td");
    tdName.textContent = c.name;

    const tdRemaining = document.createElement("td");
    tdRemaining.className = "center";
    tdRemaining.textContent = fmtCents(c.remaining_cents);

    const tdSpent = document.createElement("td");
    tdSpent.className = "center";
    tdSpent.textContent = fmtCents(c.spent_cents);

    tr.appendChild(tdName);
    tr.appendChild(tdRemaining);
    tr.appendChild(tdSpent);
    catTableBody.appendChild(tr);
  }

  // Dropdowns
  txCategory.innerHTML = "";
  txFromCategory.innerHTML = "";
  txToCategory.innerHTML = "";

  for (const c of cats){
    const opt = document.createElement("option");
    opt.value = String(c.category_id);
    opt.textContent = c.name;
    txCategory.appendChild(opt);

    const o1 = document.createElement("option");
    o1.value = String(c.category_id);
    o1.textContent = c.name;
    txFromCategory.appendChild(o1);

    const o2 = document.createElement("option");
    o2.value = String(c.category_id);
    o2.textContent = c.name;
    txToCategory.appendChild(o2);
  }

  HISTORY_CATEGORY_MAP = new Map(cats.map(c => [c.category_id, c.name]));
}
</script>

<script>
/* ================= HISTORY MODAL (NO CATEGORY NUMBERS) ================= */
let HISTORY_MODE = "current"; // current | prior

function escapeHtml(s){
  return String(s || "")
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

function labelForCategoryId(id){
  const name = HISTORY_CATEGORY_MAP.get(Number(id));
  return name || "Unknown category";
}

function labelForType(it){
  if (it.is_refund) return "Refund";
  if (String(it.note || "").startsWith("Transfer:")) return "Transfer";
  return "Expense";
}

function signedAmountCents(it){
  const sign = it.is_refund ? -1 : 1;
  return sign * Number(it.amount_cents || 0);
}

function normalizeLedgerItems(items){
  const arr = Array.isArray(items) ? items : [];
  return arr.map(x => ({
    id: String(x.id || ""),
    period_key: String(x.period_key || ""),
    category_id: Number(x.category_id),
    amount_cents: Number(x.amount_cents) || 0,
    is_refund: Boolean(x.is_refund),
    note: String(x.note || ""),
    created_at: String(x.created_at || ""),
    created_by_label: String(x.created_by_label || "")
  })).filter(x => x.id && x.period_key && Number.isFinite(x.category_id));
}

function openHistory(mode = "current"){
  HISTORY_MODE = mode === "prior" ? "prior" : "current";
  show(historyOverlay);
  historyOverlay.setAttribute("aria-hidden","false");
  setStatus(historyStatus, "");
  historyBody.innerHTML = "";

  historyCurrentBtn.disabled = HISTORY_MODE === "current";
  historyPriorBtn.disabled = HISTORY_MODE === "prior";

  loadAndRenderHistory().catch((e) => setStatus(historyStatus, e?.message || String(e), "error"));
}

function closeHistory(){
  hide(historyOverlay);
  historyOverlay.setAttribute("aria-hidden","true");
}

async function loadAndRenderHistory(){
  const token = await idbGet(KEY_TOKEN);
  if (!token) { closeHistory(); return showAuth("Missing token. Please re-enter.", true); }
  if (!CURRENT_STATE) return setStatus(historyStatus, "No budget loaded yet.", "error");

  const cur = CURRENT_STATE?.period;
  const prior = CURRENT_STATE?.prior_period;

  if (HISTORY_MODE === "prior"){
    if (!prior?.period_key) return setStatus(historyStatus, "No prior period available yet.", "error");
    historyTitle.textContent = `History — ${String(prior.start_ts).slice(0,10)} → ${String(prior.end_ts).slice(0,10)}`;
    // NOTE: with your current Worker, GET /transactions returns current period only.
    // So we show a clear message instead of broken/empty UI.
    return setStatus(historyStatus, "Prior-period history requires a small server change (period_key query). Current API returns only current-period ledger.", "error");
  }

  historyTitle.textContent = cur?.start_ts && cur?.end_ts
    ? `History — ${String(cur.start_ts).slice(0,10)} → ${String(cur.end_ts).slice(0,10)}`
    : "History — Current Period";

  setStatus(historyStatus, "Loading…");
  const res = await fetchTransactions(token, { limit: 500 });
  if (res.authFailed){
    await idbDel(KEY_TOKEN);
    closeHistory();
    return showAuth("Token invalid/expired. Please re-enter.", true);
  }

  const payload = res.result || {};
  const items = normalizeLedgerItems(payload.items || []);
  setStatus(historyStatus, items.length ? "" : "No transactions found for this period.");

  historyBody.innerHTML = "";
  for (const it of items){
    const tr = document.createElement("tr");

    const tdWhen = document.createElement("td");
    tdWhen.textContent = fmtLocalDateTime(it.created_at);

    const tdWho = document.createElement("td");
    tdWho.textContent = it.created_by_label || "—";

    const tdType = document.createElement("td");
    tdType.textContent = labelForType(it);

    const tdCat = document.createElement("td");
    tdCat.textContent = labelForCategoryId(it.category_id); // Option A: no numbers

    const tdAmt = document.createElement("td");
    tdAmt.className = "right";
    const amt = signedAmountCents(it);
    tdAmt.textContent = (amt < 0 ? "-" : "") + fmtCents(Math.abs(amt));

    const tdNote = document.createElement("td");
    tdNote.innerHTML = it.note ? escapeHtml(it.note) : "";

    tr.appendChild(tdWhen);
    tr.appendChild(tdWho);
    tr.appendChild(tdType);
    tr.appendChild(tdCat);
    tr.appendChild(tdAmt);
    tr.appendChild(tdNote);
    historyBody.appendChild(tr);
  }
}

/* History events */
openHistoryBtn.addEventListener("click", () => openHistory("current"));
historyCloseBtn.addEventListener("click", closeHistory);
historyOverlay.addEventListener("click", (e) => { if (e.target === historyOverlay) closeHistory(); });
historyCurrentBtn.addEventListener("click", () => openHistory("current"));
historyPriorBtn.addEventListener("click", () => openHistory("prior"));
</script>
<script>
/* ================= TRANSFER UI ================= */
function syncTxTypeUi(){
  const t = String(txType.value || "expense");
  const isTransfer = t === "transfer";
  txTransferPanel.classList.toggle("hidden", !isTransfer);
  txStandardPanel.classList.toggle("hidden", isTransfer);
  setStatus(txStatus, "");
}

txType.addEventListener("change", syncTxTypeUi);
syncTxTypeUi();

txAmount.addEventListener("blur", () => { 
  txAmount.value = validateAndFixCommas(txAmount.value);
  txAmount.value = normalizeMoneyDisplay(txAmount.value); 
});

txTransferAmount.addEventListener("blur", () => { 
  txTransferAmount.value = validateAndFixCommas(txTransferAmount.value);
  txTransferAmount.value = normalizeMoneyDisplay(txTransferAmount.value); 
});

function buildTransferItems({ fromId, toId, cents, note }){
  const n = String(note || "").trim().slice(0, 200);
  const prefix = `Transfer: ${labelForCategoryId(fromId)} → ${labelForCategoryId(toId)}`;
  const fullNote = n ? `${prefix} • ${n}` : prefix;

  return [
    { category_id: fromId, amount_cents: cents, is_refund: false, note: fullNote },
    { category_id: toId,   amount_cents: cents, is_refund: true,  note: fullNote }
  ];
}

/* ================= TRANSACTIONS SUBMIT ================= */
txSubmitBtn.addEventListener("click", async () => {
  const token = await idbGet(KEY_TOKEN);
  const name = await idbGet(KEY_NAME);

  if (!token) return showAuth("Missing token. Please re-enter.", true);
  if (!name) return showAuth("Missing name. Please re-enter.", true);
  if (!CURRENT_STATE) return setStatus(txStatus, "No budget loaded yet.", "error");

  const mode = String(txType.value || "expense");

  // Transfer
  if (mode === "transfer"){
    const fromId = Number(txFromCategory.value);
    const toId = Number(txToCategory.value);
    if (!Number.isFinite(fromId) || fromId <= 0) return setStatus(txStatus, "Choose a 'Transfer from' category.", "error");
    if (!Number.isFinite(toId) || toId <= 0) return setStatus(txStatus, "Choose a 'Transfer to' category.", "error");
    if (fromId === toId) return setStatus(txStatus, "Transfer from/to must be different categories.", "error");

    const cents = dollarsToCentsFromInput(txTransferAmount.value);
    if (cents === null) return setStatus(txStatus, "Enter a valid transfer amount greater than $0.00.", "error");

    const note = String(txTransferNote.value || "").trim().slice(0, 240) || "";

    const body = { created_by_label: name, items: buildTransferItems({ fromId, toId, cents, note }) };

    setStatus(txStatus, "Saving transfer…");
    try {
      const res = await postTransaction(token, body);
      if (res.authFailed){
        await idbDel(KEY_TOKEN);
        return showAuth("Token invalid/expired. Please re-enter.", true);
      }
      CURRENT_STATE = res.result || {};
      await renderDashboard(CURRENT_STATE);
      setStatus(txStatus, "Transfer saved.", "ok");
      txTransferAmount.value = "";
      txTransferNote.value = "";
    } catch (e) {
      setStatus(txStatus, e?.message || String(e), "error");
    }
    return;
  }

  // Expense / Refund
  const categoryId = Number(txCategory.value);
  if (!Number.isFinite(categoryId) || categoryId <= 0) return setStatus(txStatus, "Please choose a category.", "error");

  const cents = dollarsToCentsFromInput(txAmount.value);
  if (cents === null) return setStatus(txStatus, "Enter a valid amount greater than $0.00.", "error");

  const isRefund = mode === "refund";
  const note = String(txNote.value || "").trim().slice(0, 240) || undefined;

  const body = { created_by_label: name, items: [{ category_id: categoryId, amount_cents: cents, is_refund: isRefund, note }] };

  setStatus(txStatus, "Saving…");
  try {
    const res = await postTransaction(token, body);
    if (res.authFailed){
      await idbDel(KEY_TOKEN);
      return showAuth("Token invalid/expired. Please re-enter.", true);
    }
    CURRENT_STATE = res.result || {};
    await renderDashboard(CURRENT_STATE);
    setStatus(txStatus, "Saved.", "ok");
    txAmount.value = "";
    txNote.value = "";
  } catch (e) {
    setStatus(txStatus, e?.message || String(e), "error");
  }
});
</script>

<script>
/* ================= SETTINGS MODAL - REORDER FUNCTIONS ================= */
async function openReorderPanel(){
  if (!CURRENT_STATE) return setStatus(settingsReorderStatus, "No budget loaded yet.", "error");
  
  const cats = normalizeCategories(CURRENT_STATE);
  if (cats.length === 0) return setStatus(settingsReorderStatus, "No categories to reorder.", "error");

  show(settingsReorderPanel);
  setStatus(settingsReorderStatus, "");
  
  // Apply current saved order
  const ordered = await applyUiOrder(cats);
  renderReorderList(ordered);
}

async function renderReorderList(cats){
  settingsReorderList.innerHTML = "";

  for (let i = 0; i < cats.length; i++){
    const c = cats[i];
    const wrap = document.createElement("div");
    wrap.className = "row";
    wrap.style.marginTop = "10px";
    wrap.dataset.categoryId = String(c.category_id);
    
    const label = document.createElement("span");
    label.textContent = c.name;
    label.style.flex = "1";
    label.style.alignSelf = "center";

    const upBtn = document.createElement("button");
    upBtn.className = "secondary";
    upBtn.type = "button";
    upBtn.textContent = "↑";
    upBtn.disabled = i === 0;
    upBtn.addEventListener("click", () => moveCategory(i, -1));

    const downBtn = document.createElement("button");
    downBtn.className = "secondary";
    downBtn.type = "button";
    downBtn.textContent = "↓";
    downBtn.disabled = i === cats.length - 1;
    downBtn.addEventListener("click", () => moveCategory(i, 1));

    wrap.appendChild(label);
    wrap.appendChild(upBtn);
    wrap.appendChild(downBtn);
    settingsReorderList.appendChild(wrap);
  }
}

function moveCategory(index, direction){
  const rows = Array.from(settingsReorderList.querySelectorAll(".row"));
  if (index < 0 || index >= rows.length) return;
  
  const newIndex = index + direction;
  if (newIndex < 0 || newIndex >= rows.length) return;

  // Get current order from DOM
  const currentOrder = rows.map(r => Number(r.dataset.categoryId));
  
  // Swap in the array
  [currentOrder[index], currentOrder[newIndex]] = [currentOrder[newIndex], currentOrder[index]];
  
  // Get categories data
  const cats = normalizeCategories(CURRENT_STATE);
  const catsById = new Map(cats.map(c => [c.category_id, c]));
  
  // Build ordered list based on new order
  const ordered = currentOrder.map(id => catsById.get(id)).filter(Boolean);
  
  // Re-render with new order
  renderReorderList(ordered);
}

async function saveReorder(){
  const rows = Array.from(settingsReorderList.querySelectorAll(".row"));
  const order = rows.map(r => Number(r.dataset.categoryId)).filter(n => Number.isFinite(n) && n > 0);
  
  if (order.length === 0) return setStatus(settingsReorderStatus, "No categories to save.", "error");

  try {
    await idbSet(KEY_CAT_ORDER, order);
    setStatus(settingsReorderStatus, "Order saved.", "ok");
    
    // Update the dashboard to reflect new order
    await renderDashboard(CURRENT_STATE);
    
    // Hide panel after a brief delay
    setTimeout(() => {
      hide(settingsReorderPanel);
      setStatus(settingsReorderStatus, "");
    }, 1000);
  } catch (e) {
    setStatus(settingsReorderStatus, e?.message || String(e), "error");
  }
}

/* ================= SETTINGS MODAL - EDIT BUDGETS FUNCTIONS ================= */
async function openEditBudgetsPanel(){
  if (!CURRENT_STATE) return setStatus(settingsEditBudgetsStatus, "No budget loaded yet.", "error");
  
  const cats = normalizeCategories(CURRENT_STATE);
  if (cats.length === 0) return setStatus(settingsEditBudgetsStatus, "No categories to edit.", "error");

  show(settingsEditBudgetsPanel);
  setStatus(settingsEditBudgetsStatus, "");
  
  const ordered = await applyUiOrder(cats);
  renderEditBudgetsList(ordered);
}

function renderEditBudgetsList(cats){
  settingsEditBudgetsList.innerHTML = "";

  for (const c of cats){
    const currentBudget = (c.spent_cents + c.remaining_cents) / 100;
    
    const wrap = document.createElement("div");
    wrap.className = "row";
    wrap.style.marginTop = "10px";
    wrap.dataset.categoryId = String(c.category_id);
    
    const label = document.createElement("label");
    label.textContent = c.name;
    label.style.flex = "1";
    label.style.alignSelf = "center";
    label.style.marginTop = "0";

    const input = document.createElement("input");
    input.className = "editBudgetInput";
    input.placeholder = "$0.00";
    input.value = currentBudget.toFixed(2);
    input.inputMode = "decimal";
    input.style.flex = "1";
    
    input.addEventListener("blur", () => { 
      input.value = validateAndFixCommas(input.value);
      input.value = normalizeMoneyDisplay(input.value); 
    });

    wrap.appendChild(label);
    wrap.appendChild(input);
    settingsEditBudgetsList.appendChild(wrap);
  }
}

function readEditBudgets(){
  const rows = Array.from(settingsEditBudgetsList.querySelectorAll(".row"));
  return rows.map(r => {
    const categoryId = Number(r.dataset.categoryId);
    const input = r.querySelector(".editBudgetInput");
    const value = input?.value || "";
    const cents = dollarsToCentsFromInput(value);
    return { categoryId, cents };
  }).filter(x => Number.isFinite(x.categoryId) && x.categoryId > 0);
}

async function saveEditBudgets(){
  const token = await idbGet(KEY_TOKEN);
  if (!token) return showAuth("Missing token. Please re-enter.", true);

  const edits = readEditBudgets();
  if (!edits.length) return setStatus(settingsEditBudgetsStatus, "No budgets to save.", "error");

  for (const edit of edits){
    if (edit.cents === null || edit.cents <= 0) {
      return setStatus(settingsEditBudgetsStatus, "All budget amounts must be greater than $0.00", "error");
    }
  }

  // The API doesn't have a direct "update budget" endpoint, so we need to use transactions
  // to adjust budgets. We'll calculate the difference and post refunds/expenses to adjust.
  const cats = normalizeCategories(CURRENT_STATE);
  const adjustments = [];
  
  for (const edit of edits){
    const cat = cats.find(c => c.category_id === edit.categoryId);
    if (!cat) continue;
    
    const currentBudget = cat.spent_cents + cat.remaining_cents;
    const diff = edit.cents - currentBudget;
    
    if (diff !== 0) {
      // Positive diff = increase budget (refund), negative = decrease (expense)
      adjustments.push({
        category_id: edit.categoryId,
        amount_cents: Math.abs(diff),
        is_refund: diff > 0,
        note: `Budget adjustment: ${diff > 0 ? 'increased' : 'decreased'} by ${fmtCents(Math.abs(diff))}`
      });
    }
  }

  if (adjustments.length === 0) {
    return setStatus(settingsEditBudgetsStatus, "No changes to save.", "ok");
  }

  const name = await idbGet(KEY_NAME);
  if (!name) return showAuth("Missing name. Please re-enter.", true);

  const payload = {
    created_by_label: name,
    items: adjustments
  };

  setStatus(settingsEditBudgetsStatus, "Saving…");
  try {
    const res = await postTransaction(token, payload);
    if (res.authFailed){
      await idbDel(KEY_TOKEN);
      closeSettings();
      return showAuth("Token invalid/expired. Please re-enter.", true);
    }

    CURRENT_STATE = res.result || {};
    await renderDashboard(CURRENT_STATE);
    setStatus(settingsEditBudgetsStatus, "Saved.", "ok");
    
    setTimeout(() => {
      hide(settingsEditBudgetsPanel);
      setStatus(settingsEditBudgetsStatus, "");
    }, 1000);
  } catch (e) {
    setStatus(settingsEditBudgetsStatus, e?.message || String(e), "error");
  }
}

/* ================= SETTINGS MODAL - ADD CATEGORIES FUNCTIONS ================= */
function openAddCatsPanel(){
  show(settingsAddCatsPanel);
  setStatus(settingsAddCatsStatus, "");
  settingsAddCatsList.innerHTML = "";
  addSettingsCatRow("", "");
}

function addSettingsCatRow(name = "", budget = ""){
  const wrap = document.createElement("div");
  wrap.className = "row";
  wrap.style.marginTop = "10px";
  wrap.innerHTML = `
    <input class="settingsCatName" placeholder="Category name" value="${String(name).replaceAll('"','&quot;')}" />
    <input class="settingsCatBudget" placeholder="$0.00" value="${String(budget).replaceAll('"','&quot;')}" inputmode="decimal" />
    <button type="button" class="secondary settingsRemoveCatBtn">Remove</button>
  `;
  
  const budgetInput = wrap.querySelector(".settingsCatBudget");
  budgetInput.addEventListener("blur", () => { 
    budgetInput.value = validateAndFixCommas(budgetInput.value);
    budgetInput.value = normalizeMoneyDisplay(budgetInput.value); 
  });
  
  wrap.querySelector(".settingsRemoveCatBtn").addEventListener("click", () => wrap.remove());
  settingsAddCatsList.appendChild(wrap);
}

function readSettingsAddCats(){
  const rows = Array.from(settingsAddCatsList.querySelectorAll(".row"));
  return rows.map(r => {
    const name = (r.querySelector(".settingsCatName")?.value || "").trim();
    const money = (r.querySelector(".settingsCatBudget")?.value || "").trim();
    const cents = dollarsToCentsFromInput(money);
    return { name, cents };
  });
}

/* ================= SETTINGS MODAL - EVENT LISTENERS ================= */
function openSettings(){
  show(settingsOverlay);
  settingsOverlay.setAttribute("aria-hidden","false");
  setStatus(settingsAccountStatus, "");
  setStatus(settingsReorderStatus, "");
  setStatus(settingsEditBudgetsStatus, "");
  setStatus(settingsAddCatsStatus, "");
  hide(settingsReorderPanel);
  hide(settingsEditBudgetsPanel);
  hide(settingsAddCatsPanel);
}

function closeSettings(){
  hide(settingsOverlay);
  settingsOverlay.setAttribute("aria-hidden","true");
}

openSettingsBtn.addEventListener("click", openSettings);
settingsCloseBtn.addEventListener("click", closeSettings);
settingsOverlay.addEventListener("click", (e) => { if (e.target === settingsOverlay) closeSettings(); });

/* Reorder */
settingsOpenReorderBtn.addEventListener("click", openReorderPanel);

settingsCancelOrderBtn.addEventListener("click", () => {
  hide(settingsReorderPanel);
  setStatus(settingsReorderStatus, "");
});

settingsSaveOrderBtn.addEventListener("click", saveReorder);

/* Edit budgets */
settingsOpenEditBudgetsBtn.addEventListener("click", openEditBudgetsPanel);

settingsCancelEditBudgetsBtn.addEventListener("click", () => {
  hide(settingsEditBudgetsPanel);
  setStatus(settingsEditBudgetsStatus, "");
});

settingsSaveEditBudgetsBtn.addEventListener("click", saveEditBudgets);

/* Add categories panel */
settingsOpenAddCatsBtn.addEventListener("click", openAddCatsPanel);
settingsAddCatsRowBtn.addEventListener("click", () => addSettingsCatRow("", ""));

settingsCancelCatsBtn.addEventListener("click", () => {
  hide(settingsAddCatsPanel);
  setStatus(settingsAddCatsStatus, "");
});

async function saveAddedCategories(){
  const token = await idbGet(KEY_TOKEN);
  if (!token) return showAuth("Missing token. Please re-enter.", true);

  const rows = readSettingsAddCats()
    .filter(x => x.name || x.cents !== null);

  if (!rows.length) return setStatus(settingsAddCatsStatus, "Add at least one category.", "error");

  for (const r of rows){
    if (!r.name) return setStatus(settingsAddCatsStatus, "Each row needs a category name.", "error");
    if (r.cents === null) return setStatus(settingsAddCatsStatus, `Enter a valid budget for: ${r.name}`, "error");
  }

  const payload = {
    add: rows.map((r) => ({ name: r.name, budget_cents: r.cents })),
    remove: []
  };

  setStatus(settingsAddCatsStatus, "Saving…");
  try {
    const res = await postCategories(token, payload);
    if (res.authFailed){
      await idbDel(KEY_TOKEN);
      closeSettings();
      return showAuth("Token invalid/expired. Please re-enter.", true);
    }

    // budgets/categories changed => ensure UI order includes new IDs
    CURRENT_STATE = res.result || {};
    await renderDashboard(CURRENT_STATE);
    setStatus(settingsAddCatsStatus, "Saved.", "ok");
    settingsAddCatsList.innerHTML = "";
    addSettingsCatRow("", "");
  } catch (e) {
    setStatus(settingsAddCatsStatus, e?.message || String(e), "error");
  }
}
settingsSaveCatsBtn.addEventListener("click", saveAddedCategories);

/* Account */
settingsLogoutBtn.addEventListener("click", async () => {
  await idbDel(KEY_TOKEN);
  await idbDel(KEY_NAME);
  await idbDel(KEY_CAT_ORDER);
  closeSettings();
  showAuth("Logged out. Enter your name and bearer token to continue.");
});

settingsResetBtn.addEventListener("click", async () => {
  const token = await idbGet(KEY_TOKEN);
  if (!token) return showAuth("Missing token. Please re-enter.", true);

  const ok = window.confirm("This will DELETE all categories, budgets, and transactions from the server. Continue?");
  if (!ok) return;

  setStatus(settingsAccountStatus, "Resetting…");
  try {
    const res = await postReset(token);
    if (res.authFailed){
      await idbDel(KEY_TOKEN);
      closeSettings();
      return showAuth("Token invalid/expired. Please re-enter.", true);
    }

    await idbDel(KEY_CAT_ORDER);

    setStatus(settingsAccountStatus, "Reset complete.", "ok");
    closeSettings();

    await bootstrap(); // will fall into wizard
  } catch (e) {
    setStatus(settingsAccountStatus, e?.message || String(e), "error");
  }
});
</script>

<script>
/* ================= BOOTSTRAP ================= */
async function loadAppStateAndRender(token){
  const { authFailed, state } = await fetchState(token);
  if (authFailed){
    await idbDel(KEY_TOKEN);
    await idbDel(KEY_NAME);
    return showAuth("Token invalid/expired. Please re-enter.", true);
  }

  // Not initialized
  if (!state || state.initialized === false){
    return showWizard();
  }

  CURRENT_STATE = state;
  showApp();
  await renderDashboard(CURRENT_STATE);
  setStatus(globalStatus, "");
}

async function bootstrap(){
  const token = await idbGet(KEY_TOKEN);
  const name = await idbGet(KEY_NAME);

  if (!token || !name){
    return showAuth("Enter your name and bearer token to continue.");
  }

  // Optional: re-validate quietly (helps if token rotated)
  try {
    const ok = await validateToken(token);
    if (!ok){
      await idbDel(KEY_TOKEN);
      await idbDel(KEY_NAME);
      return showAuth("Token invalid/expired. Please re-enter.", true);
    }
  } catch (e) {
    // If validate endpoint is down, still try state (better UX)
    void e;
  }

  try {
    await loadAppStateAndRender(token);
  } catch (e) {
    setStatus(globalStatus, e?.message || String(e), "error");
    // show auth so user isn't stuck with blank app
    showAuth("Could not load budget state. See error below.", true);
    setStatus(authStatus, e?.message || String(e), "error");
  }
}

/* Safety: surface unhandled rejections */
window.addEventListener("unhandledrejection", (ev) => {
  const msg = ev?.reason?.message || String(ev?.reason || "Unknown error");
  setStatus(globalStatus, `Error: ${msg}`, "error");
});

bootstrap();
</script>

</body>
</html>
